#DEFINITIONS:  -*-sh-*-

# ARTS setup file for AMSUB simulations

Arts {


# 1. General
#-----------

output_file_formatSetZippedAscii

# AMSU uses Planck brightness temperatures
# ---
StringSet( y_unit ){ "PlanckBT" }
StringSet( jacobian_unit ){ "RJBT" }

# Surface
AgendaSet(surface_prop_agenda){
   InterpAtmFieldToRteGps( surface_skin_t, t_field )
   surfaceSimple
} 

# 2. Spectroscopy
#----------------

# We take a smaller cutoff, since the line-by-line calculation is 
# only for O3, where only the local lines matter.
# Could be speed-optimized further by selecting only the relevant 
# lines from the line list.
abs_lineshapeDefine{ shape               = "Voigt_Kuntz6"
                     normalizationfactor = "VVH"
                     cutoff              = 5e9 }

SpeciesSet(abs_species){["H2O-PWR98",
                         "O3",
			 "O2-PWR93",
			 "N2-SelfContStandardType"]}

# Read HITRAN catalog (needed for O3):
#abs_linesReadFromHitran2004{
#   filename = "/storage1/pool/lookup2/hitran2004/HITRAN04.par"
#   fmin     = 80e9
#   fmax     = 200e9 
#}
#WriteXML(abs_lines){"amsu/amsub.hitran04_lines.xml"}

ReadXML(abs_lines){"amsu/amsub.hitran04_lines.xml"}
abs_lines_per_speciesCreateFromLines

# WARNING: If you redifine abs_species, and want to do a line-by-line
# calculation, you also have to call
# abs_lines_per_speciesCreateFromLines again.


# 3. Sensor:
#-----------

# Definition of sensor position and LOS
# ---
ReadXML(sensor_los){"amsu/amsub.sensor_los.xml"}
nrowsGet(sensor_los)
ncolsGet(sensor_los)
MatrixSet(sensor_pos){850e3}
sensor_posAddRgeoid


# Start sensor response setup
# ---

# Normalise the sensor response
# ---
IndexSet(sensor_norm){ 1 }

# Measurement blocks
# ---
# Only zenith angles are defined for 1D atmosphere
IndexSet(nelem){ 1 }
VectorSet( mblock_za_grid ){
  value = 0
}

# Antenna dimensionality
# --- 
AntennaSet1D

# The local oscillators of each mixer
# ---
# The local oscillator frequency must be given for each channel, even if
# several channels use the same mixer. 
VectorSetExplicitly(lo){
  values = [89e9, 150e9, 183.31e9, 183.31e9, 183.31e9]
}

# The backend channel frequencies
# ---
# The number of backend channel frequencies should either be equal to the
# number of mixers, i.e. elements of *lo*, or one.
# Note that only one of the sidebands are defined in ARTS, here the upper
# side is chosen but the choice is arbitrary.
VectorSetExplicitly(f_backend){
  values = [89.9e9, 150.9e9, 184.31e9, 186.31e9, 190.31e9]
}

# Backend channel response
# ---
# The channel backend respones have to be defined for the setup of the 
# multi-mixer response. Monochromatic radiances can be approximated with 
# very narrow channel responses (narrower than the spacing in *f_grid*)
# ---
MatrixCreate(backend_channel_response)
ReadXML(backend_channel_response){"amsu/amsub.backend.xml"}

# Calculate f_grid
# ---
f_gridFromSensor

WriteXML(f_grid){""}

# Initialise sensor response
# ---
sensor_responseInit

# The number of polarisations
# ---
# In the multi-mixer setup each mixer is related to a polarisation state. 
# Several mixers can of course be related to the same polarisation state, 
# but the polarisation state has then to be repeated for every mixer.
# The number of polarisation states, given by the rows of *sensor_pol*, 
# shoud be equal to the number of mixers, given by the elements of *lo*.
# ---
# Here we construct a matrix with the desired number of rows, but with 
# the same polarisation reponse for each mixer.
IndexSet(nrows){ 5 }
IndexSet(ncols){ 1 }
MatrixSet(sensor_pol){ 2 }

# Setup the polarisation response
# ---
sensor_responsePolarisation

# Sidebands filter response
# ---
# For true double sideband mixers the response can be represented by a 
# constant line at one for all frequencies.
# The sideband filter has to cover the entire frequency range of 
# *f_grid* so only two points on each side of *f_grid* is needed to 
# the describe the constant response.
# Also, the same filter response is used for all channels and it is
# sufficient to give the filter function once. This can be described 
# by a 2x2 matrix.
IndexSet(nelem){2}
VectorNLinSpace(vector_1){
  start = 85e9
  stop = 200e9
}
IndexSet(nelem){ 2 }
VectorSet(vector_2){
  value = 1
}
# The WSV sideband_filter_response is created on the fly here, it is
# not a standard WSV.
Matrix2ColFromVectors(sideband_filter_response,vector_1,vector_2){}

# The multi-mixer response
# ---
sensor_responseMultiMixerBackend(sideband_filter_response){}

# Write the sensor variable to xml-files
#WriteXML(sensor_response){ "" }
#WriteXML(sensor_response_f){ "" }

# End of sensor response setup


}
