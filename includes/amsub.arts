# ARTS setup file for AMSUB simulations

Arts {

INCLUDE "general.arts"
INCLUDE "continua.arts"


output_file_formatSetZippedAscii

ReadXML(f_grid){"amsub.f_grid.xml"}

# We take a smaller cutoff, since the line-by-line calculation is 
# only for O3, where only the local lines matter.
# Could be speed-optimized further by selecting only the relevant 
# lines from the line list.
abs_lineshapeDefine{ shape               = "Voigt_Kuntz6"
                     normalizationfactor = "VVH"
                     cutoff              = 5e9 }

SpeciesSet(abs_species){["H2O-PWR98",
                         "O3",
			 "O2-PWR93",
			 "N2-SelfContStandardType"]}

# Read HITRAN catalog (needed for O3):
#abs_linesReadFromHitran2004{
#   filename = "/storage1/pool/lookup2/hitran2004/HITRAN04.par"
#   fmin     = 80e9
#   fmax     = 200e9 
#}
#WriteXML(abs_lines){"amsub.hitran04_lines.xml"}

ReadXML(abs_lines){"amsub.hitran04_lines.xml"}
abs_lines_per_speciesCreateFromLines


# AMSU uses Planck brightness temperatures
# ---
StringSet( y_unit ){ "PlanckBT" }



# Sensor part:

# Definition of sensor position and LOS
# ---
ReadXML(sensor_los){"amsub.sensor_los.xml"}
nrowsGet(sensor_los)
ncolsGet(sensor_los)
MatrixSet(sensor_pos){850e3}
sensor_posAddRgeoid


# Start sensor response setup
# ---

# Normalise the sensor response
# ---
IndexSet(sensor_norm){ 1 }

# Measurement blocks
# ---
# Only zenith angles are defined for 1D atmosphere
IndexSet(nelem){ 1 }
VectorSet( mblock_za_grid ){
  value = 0
}

# Antenna dimensionality
# --- 
AntennaSet1D

# Initialise sensor response
# ---
sensor_responseInit

# The number of polarisations
# ---
# In the multi-mixer setup each mixer is related to a polarisation state. 
# Several mixers can of course be related to the same polarisation state, 
# but the polarisation state has then to be repeated for every mixer.
# The number of polarisation states, given by the rows of *sensor_pol*, 
# shoud be equal to the number of mixers, given by the elements of *lo*.
# ---
# Here we construct a matrix with the desired number of rows, but with 
# the same polarisation reponse for each mixer.
IndexSet(nrows){ 5 }
IndexSet(ncols){ 1 }
MatrixSet(sensor_pol){ 2 }

# Setup the polarisation response
# ---
sensor_responsePolarisation

# The local oscillators of each mixer
# ---
# The local oscillator frequency must be given for each channel, even if
# several channels use the same mixer. 
VectorSetExplicitly(lo){
  values = [89e9, 150e9, 183.31e9, 183.31e9, 183.31e9]
}

# Sidebands filter response
# ---
# For true double sideband mixers the response can be represented by a 
# constant line at one for all frequencies.
# The sideband filter has to cover the entire frequency range of 
# *f_grid* so only two points on each side of *f_grid* is needed to 
# the describe the constant response.
# Also, the same filter response is used for all channels and it is
# sufficient to give the filter function once. This can be described 
# by a 2x2 matrix.
VectorNLinSpace(vector_1){
  start = 85e9
  stop = 200e9
  n = 2
}
IndexSet(nelem){ 2 }
VectorSet(vector_2){
  value = 1
}
Matrix2ColFromVectors(matrix_1,vector_1,vector_2){}

# The backend channel frequencies
# ---
# The number of backend channel frequencies should either be equal to the
# number of mixers, i.e. elements of *lo*, or one.
# Note that only one of the sidebands are defined in ARTS, here the upper
# side is chosen but the choice is arbitrary.
VectorSetExplicitly(f_backend){
  values = [89.9e9, 150.9e9, 184.31e9, 186.31e9, 190.31e9]
}

# Backend channel response
# ---
# The channel backend respones have to be defined for the setup of the 
# multi-mixer response. Monochromatic radiances can be approximated with 
# very narrow channel responses (narrower than the spacing in *f_grid*)
# ---
ReadXML(matrix_2){"./amsub.backend.xml"}

# The multi-mixer response
# ---
sensor_responseMultiMixerBackend(matrix_1, matrix_2){}

# Write the sensor variable to xml-files
#WriteXML(sensor_response){ "" }
#WriteXML(sensor_response_f){ "" }

# End of sensor response setup




} # End Arts
