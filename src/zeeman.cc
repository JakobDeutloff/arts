/* Copyright (C) 2014
   Richard Larsson <ric.larsson@gmail.com>

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
   USA. */


#include "zeeman.h"
#include "linefunctions.h"
#include "linescaling.h"
#include "species_info.h"

inline Numeric zeeman_magnetic_magnitude(Numeric u, Numeric v, Numeric w) noexcept
{
  /*
   *   H = ||{u, v, w}||
   */
  return std::sqrt(u*u + v*v + w*w);
}

inline Numeric zeeman_magnetic_dmagnitude_du(Numeric u, Numeric v, Numeric w) noexcept
{
  return u / std::sqrt(u*u + v*v + w*w);
}

inline Numeric zeeman_magnetic_dmagnitude_dv(Numeric u, Numeric v, Numeric w) noexcept
{
  return v / std::sqrt(u*u + v*v + w*w);
}

inline Numeric zeeman_magnetic_dmagnitude_dw(Numeric u, Numeric v, Numeric w) noexcept
{
  return w / std::sqrt(u*u + v*v + w*w);
}

inline Numeric zeeman_magnetic_theta(Numeric u, Numeric v, Numeric w, Numeric z, Numeric a) noexcept
{
  /*
   *              ( / cos(a) sin(z) \   / u \   // || / u \ || )
   *  theta = acos( | sin(a) sin(z) | o | v |  //  || | v | || )
   *              ( \        cos(z) /   \ w / //   || \ w / || )
   */
  return std::acos((u*std::sin(z)*std::cos(a) + v*std::sin(a)*std::sin(z) + w*std::cos(z))/std::sqrt(u*u + v*v + w*w));
}

inline Numeric zeeman_magnetic_dtheta_du(Numeric u, Numeric v, Numeric w, Numeric z, Numeric a) noexcept
{
  // autogenerated with sympy from theta
  return (u*v*std::sin(a)*std::sin(z) + u*w*std::cos(z) - v*v*std::sin(z)*std::cos(a) - w*w*std::sin(z)*std::cos(a))/(std::sqrt((u*u + v*v + w*w - std::pow(u*std::sin(z)*std::cos(a) + v*std::sin(a)*std::sin(z) + w*std::cos(z), 2))/(u*u + v*v + w*w))*std::pow(u*u + v*v + w*w, 1.5));
}

inline Numeric zeeman_magnetic_dtheta_dv(Numeric u, Numeric v, Numeric w, Numeric z, Numeric a) noexcept
{
  // autogenerated with sympy from theta
  return (-u*u*std::sin(a)*std::sin(z) + u*v*std::sin(z)*std::cos(a) + v*w*std::cos(z) - w*w*std::sin(a)*std::sin(z))/(std::sqrt((u*u + v*v + w*w - std::pow(u*std::sin(z)*std::cos(a) + v*std::sin(a)*std::sin(z) + w*std::cos(z), 2))/(u*u + v*v + w*w))*std::pow(u*u + v*v + w*w, 1.5));
}

inline Numeric zeeman_magnetic_dtheta_dw(Numeric u, Numeric v, Numeric w, Numeric z, Numeric a) noexcept
{
  // autogenerated with sympy from theta
  return (-u*u*std::cos(z) + u*w*std::sin(z)*std::cos(a) - v*v*std::cos(z) + v*w*std::sin(a)*std::sin(z))/(std::sqrt((u*u + v*v + w*w - std::pow(u*std::sin(z)*std::cos(a) + v*std::sin(a)*std::sin(z) + w*std::cos(z), 2))/(u*u + v*v + w*w))*std::pow(u*u + v*v + w*w, 1.5));
}

inline Numeric zeeman_magnetic_eta(Numeric u, Numeric v, Numeric w, Numeric z, Numeric a) noexcept
{
  /*
   *              ( / -sin(a) \   [ / u \   / cos(a) sin(z) \   / u \   / u \ ]   / cos(a) sin(z) \   // / -sin(a) \   [ / u \   / cos(a) sin(z) \   / u \   / u \ ] )
   *    eta = atan( |  cos(a) | x [ | v | - | sin(a) sin(z) | o | v | * | v | ] o | sin(a) sin(z) |  //  |  cos(a) | o [ | v | - | sin(a) sin(z) | o | v | * | v | ] )
   *              ( \    0    /   [ \ w /   \        cos(z) /   \ w /   \ w / ]   \        cos(z) / //   \    0    /   [ \ w /   \        cos(z) /   \ w /   \ w / ] )
   */
  return std::atan2((u*std::cos(a)*std::cos(z) + v*std::sin(a)*std::cos(z) - w*std::sin(z))*(u*std::sin(z)*std::cos(a) + v*std::sin(a)*std::sin(z) + w*std::cos(z) - 1), (u*std::sin(a) - v*std::cos(a))*(u*std::sin(z)*std::cos(a) + v*std::sin(a)*std::sin(z) + w*std::cos(z) - 1));
}

inline Numeric zeeman_magnetic_deta_du(Numeric u, Numeric v, Numeric w, Numeric z, Numeric a) noexcept
{
  // autogenerated with sympy from eta
  return (-v*std::cos(z) + w*std::sin(a)*std::sin(z))/(u*u*std::sin(a)*std::sin(a)*std::sin(z)*std::sin(z) - u*u*std::sin(z)*std::sin(z) + u*u - 2*u*v*std::sin(a)*std::sin(z)*std::sin(z)*std::cos(a) - 2*u*w*std::sin(z)*std::cos(a)*std::cos(z) - v*v*std::sin(a)*std::sin(a)*std::sin(z)*std::sin(z) + v*v - 2*v*w*std::sin(a)*std::sin(z)*std::cos(z) + w*w*std::sin(z)*std::sin(z));
}

inline Numeric zeeman_magnetic_deta_dv(Numeric u, Numeric v, Numeric w, Numeric z, Numeric a) noexcept
{
  // autogenerated with sympy from eta
  return (u*std::cos(z) - w*std::sin(z)*std::cos(a))/(u*u*std::sin(a)*std::sin(a)*std::sin(z)*std::sin(z) - u*u*std::sin(z)*std::sin(z) + u*u - 2*u*v*std::sin(a)*std::sin(z)*std::sin(z)*std::cos(a) - 2*u*w*std::sin(z)*std::cos(a)*std::cos(z) - v*v*std::sin(a)*std::sin(a)*std::sin(z)*std::sin(z) + v*v - 2*v*w*std::sin(a)*std::sin(z)*std::cos(z) + w*w*std::sin(z)*std::sin(z));
}

inline Numeric zeeman_magnetic_deta_dw(Numeric u, Numeric v, Numeric w, Numeric z, Numeric a) noexcept
{
  // autogenerated with sympy from eta
  return -(u*std::sin(a) - v*std::cos(a))*std::sin(z)/(std::pow(u*std::sin(a) - v*std::cos(a), 2) + std::pow(u*std::cos(a)*std::cos(z) + v*std::sin(a)*std::cos(z) - w*std::sin(z), 2));
}


void zeeman_on_the_fly(ArrayOfPropagationMatrix& propmat_clearsky, 
                       ArrayOfStokesVector& nlte_source,
                       ArrayOfPropagationMatrix& dpropmat_clearsky_dx,
                       ArrayOfStokesVector& dnlte_dx_source,
                       ArrayOfStokesVector& nlte_dsource_dx,
                       const ArrayOfArrayOfSpeciesTag& abs_species, 
                       const ArrayOfRetrievalQuantity& flag_partials,
                       const ArrayOfArrayOfLineRecord& zeeman_linerecord_precalc,
                       const SpeciesAuxData& isotopologue_ratios, 
                       const SpeciesAuxData& partition_functions,
                       const ConstVectorView f_grid,
                       const ConstVectorView rtp_vmrs, 
                       const ConstVectorView rtp_nlte, 
                       const ConstVectorView rtp_mag,
                       const ConstVectorView rtp_los,
                       const Numeric& rtp_pressure,
                       const Numeric& rtp_temperature,
                       const Index& manual_zeeman_tag,
                       const Numeric& manual_zeeman_magnetic_field_strength,
                       const Numeric& manual_zeeman_theta,
                       const Numeric& manual_zeeman_eta,
                       const Verbosity& verbosity)
{
  extern const Numeric DEG2RAD;
  
  // Find relevant derivatives in retrieval quantities positions
  const ArrayOfIndex flag_partials_positions = equivlent_propmattype_indexes(flag_partials);
  
  // Size of problem
  const Index nf = f_grid.nelem();
  const Index nq = flag_partials_positions.nelem();
  const Index ns = abs_species.nelem();
  const Index nn = rtp_nlte.nelem();
  
  // Pressure information
  const Numeric dnumdens_dmvr = number_density(rtp_pressure, rtp_temperature);
  const Numeric dnumdens_dt_dmvr = dnumber_density_dt(rtp_pressure, rtp_temperature);
  
  // Main compute vectors
  Eigen::VectorXcd F(nf);
  Eigen::MatrixXcd dF(nq, nf);
  Eigen::VectorXcd N(nn ? nf : 0);
  Eigen::MatrixXcd dN(nn ? nq : 0, nf);
  Index start, nelem;
  const auto f_grid_eigen = MapToEigen(f_grid);
  
  // Magnetic field variables
  const Numeric u = rtp_mag[0];
  const Numeric v = rtp_mag[1];
  const Numeric w = rtp_mag[2];
  const Numeric z = DEG2RAD * rtp_los[0];
  const Numeric a = DEG2RAD * rtp_los[1];
  const Numeric H =     manual_zeeman_tag ? manual_zeeman_magnetic_field_strength : zeeman_magnetic_magnitude(u, v, w      );
  const Numeric eta =   manual_zeeman_tag ? manual_zeeman_eta                     : zeeman_magnetic_eta(      u, v, w, z, a);
  const Numeric theta = manual_zeeman_tag ? manual_zeeman_theta                   : zeeman_magnetic_theta(    u, v, w, z, a);
  
  // Magnetic field derivatives... FIXME:  Deal with asymptotes! (e.g., for theta == 90)
  const bool do_mag_jacs = do_magnetic_jacobian(flag_partials) and not manual_zeeman_tag;
  const Numeric dH_du     = do_mag_jacs ? zeeman_magnetic_dmagnitude_du(u, v, w      ) : 0;
  const Numeric dH_dv     = do_mag_jacs ? zeeman_magnetic_dmagnitude_dv(u, v, w      ) : 0;
  const Numeric dH_dw     = do_mag_jacs ? zeeman_magnetic_dmagnitude_dw(u, v, w      ) : 0;
  const Numeric deta_du   = do_mag_jacs ? zeeman_magnetic_deta_du(      u, v, w, z, a) : 0;
  const Numeric deta_dv   = do_mag_jacs ? zeeman_magnetic_deta_dv(      u, v, w, z, a) : 0;
  const Numeric deta_dw   = do_mag_jacs ? zeeman_magnetic_deta_dw(      u, v, w, z, a) : 0;
  const Numeric dtheta_du = do_mag_jacs ? zeeman_magnetic_dtheta_du(    u, v, w, z, a) : 0;
  const Numeric dtheta_dv = do_mag_jacs ? zeeman_magnetic_dtheta_dv(    u, v, w, z, a) : 0;
  const Numeric dtheta_dw = do_mag_jacs ? zeeman_magnetic_dtheta_dw(    u, v, w, z, a) : 0;
  
  for(Index ispecies=0; ispecies<ns; ispecies++) {
    for(const ArrayOfLineRecord& lines: zeeman_linerecord_precalc) {
      if(not lines.nelem()) continue;
      else if(lines[0].Species()      not_eq abs_species[ispecies][0].Species() or
              lines[0].Isotopologue() not_eq abs_species[ispecies][0].Isotopologue()) continue;
      
      // Polarization
      auto polarization_scale = lines[0].ZeemanEffect().Polarization(theta, eta);
      auto dpol_deta = do_mag_jacs ? lines[0].ZeemanEffect().dPolarization_deta(theta, eta) : ZeemanDataOutput();
      auto dpol_dtheta = do_mag_jacs ? lines[0].ZeemanEffect().dPolarization_dtheta(theta, eta) : ZeemanDataOutput();
      
      // Temperature constants
      Numeric t0=-1.0, qt, qt0, dqt_dT;
      const Numeric numdens = rtp_vmrs[ispecies] * dnumdens_dmvr;
      const Numeric dnumdens_dT = rtp_vmrs[ispecies] * dnumdens_dt_dmvr;
      const Numeric dc = Linefunctions::DopplerConstant(rtp_temperature, lines[0].IsotopologueData().Mass());
      const Numeric ddc_dT = Linefunctions::dDopplerConstant_dT(rtp_temperature, lines[0].IsotopologueData().Mass());
      const Numeric isotop_ratio = isotopologue_ratios.getParam(lines[0].Species(), lines[0].Isotopologue())[0].data[0];
      const Numeric partial_pressure = rtp_pressure * rtp_vmrs[ispecies];
      
      for(const LineRecord& line: lines) {
        if(line.Ti0() not_eq t0) {
          t0 = line.Ti0();
          
          partition_function(qt0, qt, t0, rtp_temperature,
                             partition_functions.getParamType(line.Species(), line.Isotopologue()),
                             partition_functions.getParam(line.Species(), line.Isotopologue()));
          
          if(do_temperature_jacobian(flag_partials))
            dpartition_function_dT(dqt_dT, qt, rtp_temperature, temperature_perturbation(flag_partials),
                                   partition_functions.getParamType(line.Species(), line.Isotopologue()),
                                   partition_functions.getParam(line.Species(), line.Isotopologue()));
        }
        
        for(Index iz=0; iz<line.ZeemanEffect().nelem(); iz++) {
          Linefunctions::set_cross_section_for_single_line(F, dF, N, dN, start, nelem, f_grid_eigen, line,
                                                           flag_partials, flag_partials_positions, rtp_vmrs, 
                                                           rtp_nlte, rtp_pressure, rtp_temperature, dc, partial_pressure, 
                                                           isotop_ratio, H, ddc_dT, qt, dqt_dT, qt0,
                                                           abs_species, ispecies, iz, verbosity);
          
          auto F_seg =      F.segment(start, nelem);
          auto pol_real = polarization_scale.head<4>();
          auto pol_imag = polarization_scale.tail<3>();
          auto abs = propmat_clearsky[ispecies].GetData()(0, 0, joker, joker);
          
          // Propagation matrix calculations
          MapToEigen(abs).leftCols<4>().middleRows(start, nelem).noalias() += numdens * F_seg.real() * pol_real;
          MapToEigen(abs).rightCols<3>().middleRows(start, nelem).noalias() += numdens * F_seg.imag() * pol_imag;
          for(Index j=0; j<nq; j++) {
            auto dF_seg =      dF.row(j).segment(start, nelem).transpose();
            auto dabs = dpropmat_clearsky_dx[j].GetData()(0, 0, joker, joker);
            
            if(flag_partials[flag_partials_positions[j]] == JacPropMatType::Temperature) {
              MapToEigen(dabs).leftCols<4>().middleRows(start, nelem).noalias() += numdens * dF_seg.real() * pol_real + dnumdens_dT * F_seg.real() * pol_real;
              MapToEigen(dabs).rightCols<3>().middleRows(start, nelem).noalias() += numdens * dF_seg.imag() * pol_imag + dnumdens_dT * F_seg.imag() * pol_imag;
            }
            else if(flag_partials[flag_partials_positions[j]] == JacPropMatType::MagneticEta) {
              MapToEigen(dabs).leftCols<4>().middleRows(start, nelem).noalias() += numdens * F_seg.real() * dpol_deta.head<4>();
              MapToEigen(dabs).rightCols<3>().middleRows(start, nelem).noalias() += numdens * F_seg.imag() * dpol_deta.tail<3>();
            }
            else if(flag_partials[flag_partials_positions[j]] == JacPropMatType::MagneticTheta) {
              MapToEigen(dabs).leftCols<4>().middleRows(start, nelem).noalias() += numdens * F_seg.real() * dpol_dtheta.head<4>();
              MapToEigen(dabs).rightCols<3>().middleRows(start, nelem).noalias() += numdens * F_seg.imag() * dpol_dtheta.tail<3>();
            }
            else if(flag_partials[flag_partials_positions[j]] == JacPropMatType::MagneticU) {
              MapToEigen(dabs).leftCols<4>().middleRows(start, nelem).noalias() += numdens * dH_du * dF_seg.real() * pol_real + numdens * deta_du * F_seg.real() * dpol_deta.head<4>() + numdens * dtheta_du * F_seg.real() * dpol_dtheta.head<4>();
              MapToEigen(dabs).rightCols<3>().middleRows(start, nelem).noalias() += numdens * dH_du * dF_seg.imag() * pol_imag + numdens * deta_du * F_seg.imag() * dpol_deta.tail<3>() + numdens * dtheta_du * F_seg.imag() * dpol_dtheta.tail<3>();
            }
            else if(flag_partials[flag_partials_positions[j]] == JacPropMatType::MagneticV) {
              MapToEigen(dabs).leftCols<4>().middleRows(start, nelem).noalias() += numdens * dH_dv * dF_seg.real() * pol_real + numdens * deta_dv * F_seg.real() * dpol_deta.head<4>() + numdens * dtheta_dv * F_seg.real() * dpol_dtheta.head<4>();
              MapToEigen(dabs).rightCols<3>().middleRows(start, nelem).noalias() += numdens * dH_dv * dF_seg.imag() * pol_imag + numdens * deta_dv * F_seg.imag() * dpol_deta.tail<3>() + numdens * dtheta_dv * F_seg.imag() * dpol_dtheta.tail<3>();
            }
            else if(flag_partials[flag_partials_positions[j]] == JacPropMatType::MagneticW) {
              MapToEigen(dabs).leftCols<4>().middleRows(start, nelem).noalias() += numdens * dH_dw * dF_seg.real() * pol_real + numdens * deta_dw * F_seg.real() * dpol_deta.head<4>() + numdens * dtheta_dw * F_seg.real() * dpol_dtheta.head<4>();
              MapToEigen(dabs).rightCols<3>().middleRows(start, nelem).noalias() += numdens * dH_dw * dF_seg.imag() * pol_imag + numdens * deta_dw * F_seg.imag() * dpol_deta.tail<3>() + numdens * dtheta_dw * F_seg.imag() * dpol_dtheta.tail<3>();
            }
            else if(flag_partials[flag_partials_positions[j]] == JacPropMatType::VMR) {
              if(flag_partials[flag_partials_positions[j]].QuantumIdentity() < line.QuantumIdentity()) {
                MapToEigen(dabs).leftCols<4>().middleRows(start, nelem).noalias() += numdens * dF_seg.real() * pol_real + dnumdens_dmvr * F_seg.real() * pol_real;
                MapToEigen(dabs).rightCols<3>().middleRows(start, nelem).noalias() += numdens * dF_seg.imag() * pol_imag + dnumdens_dmvr * F_seg.imag() * pol_imag;
              }
            }
            else {
              MapToEigen(dabs).leftCols<4>().middleRows(start, nelem).noalias() += numdens * dF_seg.real() * pol_real;
              MapToEigen(dabs).rightCols<3>().middleRows(start, nelem).noalias() += numdens * dF_seg.imag() * pol_imag;
            }
          }
        
          // Source vector calculations
          if(nn) {
            auto B     =  planck(   line.F(), rtp_temperature);
            auto dB_dT = dplanck_dt(line.F(), rtp_temperature);
            
            auto N_seg = N.segment(start, nelem);
            auto nlte_src = nlte_source[ispecies].GetData()(0, 0, joker, joker);
            
            MapToEigen(nlte_src).leftCols<4>().middleRows(start, nelem).noalias() += B * numdens * N_seg.real() * pol_real;
            for(Index j=0; j<nq; j++) {
              auto dN_seg = dN.row(j).segment(start, nelem).transpose();
              auto dnlte_dx_src = dnlte_dx_source[j].GetData()(0, 0, joker, joker);
              auto nlte_dsrc_dx = nlte_dsource_dx[j].GetData()(0, 0, joker, joker);
              
              if(flag_partials[flag_partials_positions[j]] == JacPropMatType::Temperature) {
                MapToEigen(dnlte_dx_src).leftCols<4>().middleRows(start, nelem).noalias() += B * dnumdens_dT * N_seg.real() * pol_real + B * numdens * dN_seg.real() * pol_real;
                
                MapToEigen(nlte_dsrc_dx).leftCols<4>().middleRows(start, nelem).noalias() += numdens * dB_dT * N_seg.real() * pol_real;
              }
              else if(flag_partials[flag_partials_positions[j]] == JacPropMatType::MagneticEta)
                MapToEigen(dnlte_dx_src).leftCols<4>().middleRows(start, nelem).noalias() += B * numdens * N_seg.real() * dpol_deta.head<4>();
              else if(flag_partials[flag_partials_positions[j]] == JacPropMatType::MagneticTheta)
                MapToEigen(dnlte_dx_src).leftCols<4>().middleRows(start, nelem).noalias() += B * numdens * N_seg.real() * dpol_dtheta.head<4>();
              else if(flag_partials[flag_partials_positions[j]] == JacPropMatType::MagneticU)
                MapToEigen(dnlte_dx_src).leftCols<4>().middleRows(start, nelem).noalias() += B * numdens * dH_du * dN_seg.real() * pol_real + B * numdens * deta_du * N_seg.real() * dpol_deta.head<4>() + B * numdens * dtheta_du * N_seg.real() * dpol_dtheta.head<4>();
              else if(flag_partials[flag_partials_positions[j]] == JacPropMatType::MagneticV)
                MapToEigen(dnlte_dx_src).leftCols<4>().middleRows(start, nelem).noalias() += B * numdens * dH_dv * dN_seg.real() * pol_real + B * numdens * deta_dv * N_seg.real() * dpol_deta.head<4>() + B * numdens * dtheta_dv * N_seg.real() * dpol_dtheta.head<4>();
              else if(flag_partials[flag_partials_positions[j]] == JacPropMatType::MagneticW)
                MapToEigen(dnlte_dx_src).leftCols<4>().middleRows(start, nelem).noalias() += B * numdens * dH_dw * dN_seg.real() * pol_real + B * numdens * deta_dw * N_seg.real() * dpol_deta.head<4>() + B * numdens * dtheta_dw * N_seg.real() * dpol_dtheta.head<4>();
              else if(flag_partials[flag_partials_positions[j]] == JacPropMatType::VMR) {
                if(flag_partials[flag_partials_positions[j]].QuantumIdentity() < line.QuantumIdentity())
                  MapToEigen(dnlte_dx_src).leftCols<4>().middleRows(start, nelem).noalias() += B * dnumdens_dmvr * N_seg.real() * pol_real + B * numdens * dN_seg.real() * pol_real;
              }
              else
                MapToEigen(dnlte_dx_src).leftCols<4>().middleRows(start, nelem).noalias() += B * numdens * dN_seg.real() * pol_real;
            }
          }
        }
      }
    }
  }
}


void create_Zeeman_linerecordarrays(ArrayOfArrayOfLineRecord& aoaol,
                                    const ArrayOfArrayOfSpeciesTag& abs_species,
                                    const ArrayOfArrayOfLineRecord& abs_lines_per_species,
                                    const Verbosity& verbosity)
{
  CREATE_OUT3;
  
  const static Numeric margin = 1e-4;
  
  // For all species
  for(Index II = 0; II<abs_species.nelem(); II++) {
    // If the species isn't Zeeman, look at the next species
    if(!is_zeeman(abs_species[II])) continue;
    
    // If there are no lines give up on this species
    const Index nlines = abs_lines_per_species[II].nelem();
    if(not nlines) continue;
    
    // One line record array per type of polarizer is created
    aoaol.push_back(abs_lines_per_species[II]); // First is negative
    aoaol.push_back(abs_lines_per_species[II]); // Second is 0
    aoaol.push_back(abs_lines_per_species[II]); // Third is positive
    
    ArrayOfLineRecord& temp_abs_lines_sm = aoaol[aoaol.nelem()-3]; // sigma minus
    ArrayOfLineRecord& temp_abs_lines_pi = aoaol[aoaol.nelem()-2]; // pi
    ArrayOfLineRecord& temp_abs_lines_sp = aoaol[aoaol.nelem()-1]; // sigma plus
    
    // Else loop over all the lines in the species.
    for (Index ii = 0; ii < nlines; ii++)
    {
      // local LineRecord
      temp_abs_lines_sm[ii].SetZeemanEffectData(ZeemanEffectData(temp_abs_lines_sm[ii].QuantumIdentity(), ZeemanPolarizationType::SigmaMinus));
      temp_abs_lines_pi[ii].SetZeemanEffectData(ZeemanEffectData(temp_abs_lines_pi[ii].QuantumIdentity(), ZeemanPolarizationType::Pi));
      temp_abs_lines_sp[ii].SetZeemanEffectData(ZeemanEffectData(temp_abs_lines_sp[ii].QuantumIdentity(), ZeemanPolarizationType::SigmaPlus));
      
      const Numeric rel_str = temp_abs_lines_sp[ii].ZeemanEffect().SumStrengthScale() + temp_abs_lines_sm[ii].ZeemanEffect().SumStrengthScale() + temp_abs_lines_pi[ii].ZeemanEffect().SumStrengthScale();
      if(abs(rel_str - 1) > margin) {
        ostringstream os;
        os << "The lines\n" << temp_abs_lines_sm[ii] << temp_abs_lines_pi[ii] << temp_abs_lines_sp[ii]
           << "The relative strength should be 1.0 but is " << rel_str << "\n";
        throw std::runtime_error(os.str());
      }
    }
  }
}
