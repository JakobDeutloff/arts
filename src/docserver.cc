/* Copyright (C) 2010 Oliver Lemke <olemke@core-dump.info>
 
 This program is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
 USA. */

/*!
 \file   docserver.cc
 \author Oliver Lemke <olemke@core-dump.info>
 \date   2010-09-21
 
 \brief  Implementation of the arts documentation server.
 */

#include "docserver.h"

#include <string>
#include <vector>
#include <sstream>
#include <algorithm>
#include <map>
#include "libmicrohttpd/platform.h"
#include "libmicrohttpd/microhttpd.h"
#include "messages.h"
#include "methods.h"
#include "workspace_ng.h"
#include "agenda_record.h"
#include "auto_version.h"

#define DOCSERVER_NAME "ARTS built-in documentation server"

static string ds_baseurl;

void limit_line_length (ostream& os,
                        ostringstream& curline,
                        ostringstream& token,
                        const String& indent,
                        size_t linelen);

void get_short_wsv_description(String &s, const String &desc);

bool format_paragraph (String &s, const String &indent, const size_t linelen,
                       const size_t offset = 0);

//! Split string.
/** 
 Splits the string based on the given delimiter. The splitted string are
 appended to the elems vector.
 
 \param[in]      s          String to split.
 \param[in]      delim      Delimiter character.
 \param[in,out]  elems      Vector of tokens.
 
 \author Oliver Lemke
 */
void split(const string &s, char delim, vector<string> &elems)
{
  stringstream ss(s);
  string item;
  while(getline(ss, item, delim))
  {
    elems.push_back(item);
  }
}

//! Convert character to HTML entity.
/** 
 Returns a string with either the original character or the HTML entity if
 it's a special char.
 
 \param[in]  ch     Character.
 
 \returns String with original character or HTML entity.
 
 \author Oliver Lemke
 */
string ds_html_escape_char (const char ch)
{
  string ret;
  
  switch (ch)
  {
    case '<': ret.append("&lt;"); break;
    case '>': ret.append("&gt;"); break;
    default: ret.append(1, ch);
  }
  
  return ret;
}

//! Convert special characters in string to HTML entity.
/** 
 Returns a string with special characters replaced by their HTML entities.
 
 \param[in]  s     String.
 
 \returns String with original character or HTML entity.
 
 \author Oliver Lemke
 */
string ds_html_escape_string (const string& s)
{
  string ret;
  
  for (string::const_iterator it = s.begin(); it != s.end(); it++)
  {
    ret.append(ds_html_escape_char(*it));
  }
  
  return ret;
}

//! Output the docserver HTML page header to stream.
/** 
 Output the HTML header and start of the body to the stream.
 
 \param[in,out]  os     Output stream.
 \param[in]       title  Page title (default: DOCSERVER_NAME).
 
 \author Oliver Lemke
 */
void ds_begin_page (ostream &os,
                    const string& title = DOCSERVER_NAME)
{
  os
  << "<!DOCTYPE html>" << endl
  << "<html>" << endl
  << "<head>" << endl
  << "<title>" << title << "</title>" << endl
  << "<meta charset=\"utf-8\">" << endl
  << "<meta name=\"viewport\" content=\"width=device-width\" />" << endl
  << "<link rel=\"stylesheet\" href=\"" << ds_baseurl << "/styles.css\">" << endl
  << "</head>" << endl
  << "<body>" << endl;
}

//! Output the docserver HTML page footer to stream.
/** 
 Output the HTML footer and end of the body to the stream.
 
 \param[in,out]  os     Output stream.
 
 \author Oliver Lemke
 */
void ds_end_page (ostream &os)
{
  os << "<div class=\"footer\">Page generated by " << ARTS_FULL_VERSION << "</div>\n" << endl;
  os << "</body>" << endl << "</html>";
}

//! Create HTML link to an agenda.
/** 
 Returns a string with the HTML link to the agenda.
 
 \param[in]  aname     Agenda name.
 
 \returns String containing the HTML link.
 
 \author Oliver Lemke
 */
String ds_insert_agenda_link (const String &aname)
{
  ostringstream ret;
  ret << "<a href=\"" << ds_baseurl << "/agendas/" << aname << "\">" << aname << "</a>";
  return ret.str();
}

//! Create HTML link to a workspace group.
/** 
 Returns a string with the HTML link to the workspace group.
 
 \param[in]  gname     Group name.
 
 \returns String containing the HTML link.
 
 \author Oliver Lemke
 */
String ds_insert_group_link (const String &gname)
{
  ostringstream ret;
  ret << "<a href=\"" << ds_baseurl << "/groups/" << gname << "\">" << gname << "</a>";
  return ret.str();
}

//! Create HTML link to a workspace method.
/** 
 Returns a string with the HTML link to the workspace method.
 
 \param[in]  mname     Method name.
 
 \returns String containing the HTML link.
 
 \author Oliver Lemke
 */
String ds_insert_wsm_link (const String &mname)
{
  ostringstream ret;
  ret << "<a href=\"" << ds_baseurl << "/methods/" << mname << "\">" << mname << "</a>";
  return ret.str();
}

//! Create HTML link to a workspace variable.
/** 
 Returns a string with the HTML link to the workspace variable.
 
 \param[in]  vname     Variable name.
 
 \returns String containing the HTML link.
 
 \author Oliver Lemke
 */
String ds_insert_wsv_link (const String &vname)
{
  ostringstream ret;
  
  // Find wsv id:
  map<String, Index>::const_iterator it = Workspace::WsvMap.find(vname);
  if ( it != Workspace::WsvMap.end() )
  {
    if (Workspace::wsv_data[it->second].Group() == get_wsv_group_id("Agenda"))
      ret << "<a href=\"" << ds_baseurl << "/agendas/" << vname << "\">" << vname << "</a>";
    else
      ret << "<a href=\"" << ds_baseurl << "/variables/" << vname << "\">" << vname << "</a>";
  }
  
  return ret.str();
}

//! Output list of agendas to stream.
/** 
 Output an HTML list of all agenda to the stream.
 
 \param[in,out]  os     Output stream.
 
 \author Oliver Lemke
 */
void ds_list_agendas (ostream &os)
{
  Index i;
  
  os << "<tr><td colspan=\"2\">"
  << "<h2><span id=\"agendas\">Agendas</span></h2></td></tr>" << endl
  << "<tr><td><ul>" << endl;
  
  Index hitcount = 0;
  for ( i=0; i<Workspace::wsv_data.nelem(); ++i )
  {
    if (Workspace::wsv_data[i].Group() == get_wsv_group_id("Agenda"))
      hitcount++;
  }
  
  Index hitcount2 = 0;
  for ( i=0; i<Workspace::wsv_data.nelem(); ++i )
  {
    if (Workspace::wsv_data[i].Group() == get_wsv_group_id("Agenda"))
    {
      os << "<li>" << ds_insert_agenda_link(Workspace::wsv_data[i].Name()) << endl;
      hitcount2++;
      
      if (hitcount2 == hitcount/2)
        os << "</ul></td><td><ul>" << endl;
    }
  }
  
  os << "</ul></td></tr>" << endl;
}

//! Output list of workspace groups to stream.
/** 
 Output an HTML list of all workspace groups to the stream.
 
 \param[in,out]  os     Output stream.
 
 \author Oliver Lemke
 */
void ds_list_groups (ostream &os)
{
  extern const ArrayOfString wsv_group_names;
  Index i;
  
  os << "<tr><td colspan=\"2\">"
  << "<h2><span id=\"groups\">Workspace Groups</span></h2></td></tr>" << endl
  << "<tr><td><ul>" << endl;
  
  for ( i=0; i<wsv_group_names.nelem(); ++i )
  {
    os << "<li>" << ds_insert_group_link(wsv_group_names[i]) << endl;
    
    if (i+1 == wsv_group_names.nelem()/2)
      os << "</ul></td><td><ul>" << endl;
  }
  
  os << "</ul></td></tr>" << endl;
}

//! Output list of workspace methods to stream.
/** 
 Output an HTML list of all workspace methods to the stream.
 
 \param[in,out]  os     Output stream.
 
 \author Oliver Lemke
 */
void ds_list_methods (ostream &os)
{
  extern const Array<MdRecord> md_data_raw;
  Index i;
  
  os << "<tr><td colspan=\"2\">"
  << "<h2><span id=\"methods\">Workspace Methods</span></h2></td></tr>" << endl
  << "<tr><td><ul>" << endl;
  
  for ( i=0; i<md_data_raw.nelem(); ++i )
  {
    os << "<li>" << ds_insert_wsm_link(md_data_raw[i].Name()) << endl;
    
    if (i+1 == md_data_raw.nelem()/2)
      os << "</ul></td><td><ul>" << endl;
  }
  
  os << "</ul></td></tr>" << endl;
}

//! Output list of workspace variables to stream.
/** 
 Output an HTML list of all workspace variables to the stream.
 
 \param[in,out]  os     Output stream.
 
 \author Oliver Lemke
 */
void ds_list_variables (ostream &os)
{
  Index i;
  
  os << "<tr><td colspan=\"2\">"
  << "<h2><span id=\"variables\">Workspace Variables</span></h2></td></tr>" << endl
  << "<tr><td><ul>" << endl;
  
  Index hitcount = 0;
  for ( i=0; i<Workspace::wsv_data.nelem(); ++i )
  {
    if (Workspace::wsv_data[i].Group() != get_wsv_group_id("Agenda"))
      hitcount++;
  }

  Index hitcount2 = 0;
  for ( i=0; i<Workspace::wsv_data.nelem(); ++i )
  {
    if (Workspace::wsv_data[i].Group() != get_wsv_group_id("Agenda"))
    {
      os << "<li>" << ds_insert_wsv_link(Workspace::wsv_data[i].Name()) << endl;
      hitcount2++;
      
      if (hitcount2 == hitcount/2)
        os << "</ul></td><td><ul>" << endl;
    }
  }
  
  os << "</ul></td></tr>" << endl;
}

//! Output the workspace method documentation to stream.
/** 
 Output the documentation for the given workspace method to the stream in
 HTML formatting.
 
 \param[in,out]  os     Output stream.
 \param[in]      mname  Method name.
 
 \author Oliver Lemke
 */
void ds_doc_method (ostream &os, const string& mname)
{
  // Make global data visible:
  extern const Array<MdRecord>  md_data_raw;
  extern const map<String, Index> MdRawMap;
  extern const ArrayOfString wsv_group_names;
  
  // Let's first assume it is a method that the user wants to have
  // described.
  
  // Find method id:
  map<String, Index>::const_iterator it =
  MdRawMap.find(mname);
  if ( it != MdRawMap.end() )
  {
    // If we are here, then the given name matches a method.
    const MdRecord& mdr = md_data_raw[it->second];
    String indent = "";
    
    os << "<h3>Description</h3>" << endl;
    
    os << "<pre>" << endl;
    for (String::const_iterator sit = mdr.Description().begin();
         sit != mdr.Description().end(); sit++)
    {
      os << ds_html_escape_char(*sit);
    }
    os << endl << "</pre>" << endl << endl;
    
    bool is_first_author = true;
    for (Index i = 0; i < mdr.Authors().nelem(); i++)
    {
      if (is_first_author)
      {
        os << "<p><b>Authors: </b>";
        is_first_author = false;
      }
      else
        os << ", ";
      
      os << mdr.Authors()[i];
    }
    os << "\n";
    
    // Print the method's synopsis
    while (indent.length() < mdr.Name().length() + 2) indent += ' ';
    
    os << "<h3>Synopsis</h3>" << endl;
    
    ostringstream buf;
    ostringstream param;
    const size_t linelen = 2048;
    
    buf << "<p><table><tr><td>" << mdr.Name() << "(&nbsp;</td><td>";
    bool first = true;
    for ( Index i=0; i<mdr.Out().nelem(); ++i )
    {
      if (first) first=false; else buf << ", ";
      param << ds_insert_wsv_link(Workspace::wsv_data[mdr.Out()[i]].Name());
      
      limit_line_length( os, buf, param, indent, linelen );
    }
    
    for ( Index i=0; i<mdr.GOutType().nelem(); ++i )
    {
      if (first) first=false; else buf << ", ";
      if (mdr.GOut()[i].length())
        param << mdr.GOut()[i];
      else
        param << "gout" << i;
      
      limit_line_length( os, buf, param, indent, linelen );
    }
    
    const ArrayOfIndex &inonly = mdr.InOnly();
    for ( Index i=0; i<inonly.nelem(); ++i )
    {
      if (first) first=false; else buf << ", ";
      param << ds_insert_wsv_link(Workspace::wsv_data[inonly[i]].Name());
      
      limit_line_length( os, buf, param, indent, linelen );
    }
    
    for ( Index i=0; i<mdr.GInType().nelem(); ++i )
    {
      if (first) first=false; else buf << ", ";
      if (mdr.GIn()[i].length())
      {
        param << mdr.GIn()[i];
      }
      else
      {
        param << "gin" << i;
      }
      
      limit_line_length( os, buf, param, indent, linelen );
    }
    if (buf.str().length()) os << buf.str();
    
    os << " )</td></tr></table>" << endl;
    
    os << "<h3>Variables</h3>" << endl;
    
    // Out:
    indent = "";
    String desc;
    os << "<table>" << endl;
    for ( Index i=0; i<mdr.Out().nelem(); ++i )
    {
      buf.str("");
      buf << "<tr>";
      buf <<    "<td>OUT</td>";
      
      {
        const String& vname = Workspace::wsv_data[mdr.Out()[i]].Name();
        buf << "<td class=\"right\">" << ds_insert_wsv_link(vname) << "</td><td>(";
        buf << ds_insert_group_link(wsv_group_names[Workspace::wsv_data[mdr.Out()[i]].Group()]);
        buf << ")</td><td>";
      }
      
      get_short_wsv_description(desc, ds_html_escape_string(Workspace::wsv_data[mdr.Out()[i]].Description()));
      
      if (buf.str().length() + desc.length() > linelen)
      {
        format_paragraph (desc, indent, linelen);
        buf << endl << indent << desc;
      }
      else
      {
        buf << desc;
      }
      
      os << buf.str() << "</td></tr>" << endl;
    }
    
    size_t lastlen;
    bool fit;
    for ( Index i=0; i<mdr.GOut().nelem(); ++i )
    {
      buf.str("");
      buf << "<tr>";
      buf <<    "<td>GOUT</td><td class=\"right\">" << mdr.GOut()[i] << "</td><td>(";
      if (mdr.GOutType()[i] == get_wsv_group_id("Any")
          && mdr.GOutSpecType()[i].nelem())
      {
        bool firstarg = true;
        for (Index j = 0; j < mdr.GOutSpecType()[i].nelem(); j++)
        {
          if (!firstarg) buf << ", "; else firstarg = false;
          buf << ds_insert_group_link(wsv_group_names[mdr.GOutSpecType()[i][j]]);
        }
      }
      else
      {
        buf << ds_insert_group_link(wsv_group_names[mdr.GOutType()[i]]);
      }
      
      buf << ")</td><td>";
      desc = buf.str();
      lastlen = desc.length();
      fit = format_paragraph (desc, indent, linelen);
      buf.str("");
      os << desc;
      
      desc = ds_html_escape_string(mdr.GOutDescription()[i]);
      if (!fit)
      {
        format_paragraph (desc, indent, linelen);
        buf << endl << indent << desc;
      }
      else if (lastlen + desc.length() > linelen)
      {
        format_paragraph (desc, indent, linelen, lastlen);
        buf << endl << desc;
      }
      else
      {
        buf << desc;
      }
      
      os << buf.str() << "</td></tr>" << endl;
    }
    
    for ( Index i=0; i<mdr.In().nelem(); ++i )
    {
      buf.str("");
      buf << "<tr>";
      buf <<    "<td>IN</td>";
      
      const String& vname = Workspace::wsv_data[mdr.In()[i]].Name();
      buf << "<td class=\"right\">" << ds_insert_wsv_link(vname);
      buf << "</td><td>(";
      buf << ds_insert_group_link(wsv_group_names[Workspace::wsv_data[mdr.In()[i]].Group()]);
      buf << ")</td><td>";
      
      get_short_wsv_description(
                                desc, Workspace::wsv_data[mdr.In()[i]].Description());
      
      if (buf.str().length() + desc.length() > linelen)
      {
        format_paragraph (desc, indent, linelen, indent.length());
        buf << endl << indent << desc;
      }
      else
      {
        buf << desc;
      }
      
      os << buf.str() << "</td></tr>" << endl;
    }
    
    for ( Index i=0; i<mdr.GIn().nelem(); ++i )
    {
      buf.str("");
      buf << "<tr>";
      buf <<    "<td>GIN</td><td class=\"right\">" << mdr.GIn()[i] << "</td><td>(";
      if (mdr.GInType()[i] == get_wsv_group_id("Any")
          && mdr.GInSpecType()[i].nelem())
      {
        bool firstarg = true;
        for (Index j = 0; j < mdr.GInSpecType()[i].nelem(); j++)
        {
          if (!firstarg) buf << ", "; else firstarg = false;
          buf << ds_insert_group_link(wsv_group_names[mdr.GInSpecType()[i][j]]);
        }
      }
      else
      {
        buf << ds_insert_group_link(wsv_group_names[mdr.GInType()[i]]);
      }
      
      if (mdr.GInDefault()[i] != NODEF)
      {
        buf << ", Default: ";
        if (mdr.GInType()[i] == get_wsv_group_id ("String"))
        {
          buf << "\"" << mdr.GInDefault()[i] << "\"";
        }
        else
        {
          buf << mdr.GInDefault()[i];
        }
        
      }
      
      buf << ")</td><td>";
      desc = buf.str();
      lastlen = desc.length();
      fit = format_paragraph (desc, indent, linelen);
      buf.str("");
      os << desc;
      
      desc = ds_html_escape_string(mdr.GInDescription()[i]);
      if (!fit)
      {
        format_paragraph (desc, indent, linelen);
        buf << indent << desc;
      }
      else if (lastlen + desc.length() > linelen)
      {
        format_paragraph (desc, indent, linelen, indent.length());
        buf << indent << desc;
      }
      else
      {
        buf << desc;
      }
      
      os << buf.str() << "</td></tr>" << endl;
    }
    os << "</table>" << endl;
  }
}

//! Output a list of methods that can use or generate the given variable.
/** 
 Output a list of all workspace methods and agendas that use, generate or
 require the given variable.
 
 \param[in,out]  os     Output stream.
 \param[in]      vname  Variable name.
 
 \author Oliver Lemke
 */
void ds_doc_variable_methods(ostream& os, const string& vname)
{
  // Check if the user gave the name of a specific variable.
  map<String, Index>::const_iterator mi =
  Workspace::WsvMap.find(vname);
  extern const Array<MdRecord>  md_data_raw;
  if ( mi != Workspace::WsvMap.end() )
  {
    // If we are here, then the given name matches a variable.
    Index wsv_key = mi->second;
    
    // List generic methods:
    Index hitcount = 0;
    os << "<h3>Generic and supergeneric methods that can generate " << vname << "</h3>" << endl;
    os << "<ul>" << endl;
    for ( Index i=0; i<md_data_raw.nelem(); ++i )
    {
      // Get handle on method record:
      const MdRecord& mdd = md_data_raw[i];
      
      // This if statement checks whether GOutType, the list
      // of output variable types contains the group of the
      // requested variable.
      // The else clause picks up methods with supergeneric input.
      if ( count( mdd.GOutType().begin(),
                 mdd.GOutType().end(),
                 Workspace::wsv_data[wsv_key].Group() ) )
      {
        os << "<li>" << ds_insert_wsm_link(mdd.Name()) << endl;
        ++hitcount;
      }
      else if  ( count( mdd.GOutType().begin(),
                       mdd.GOutType().end(),
                       get_wsv_group_id("Any") ) )
      {
        for (Index j = 0; j < mdd.GOutType().nelem(); j++)
        {
          if (mdd.GOutType()[j] == get_wsv_group_id("Any"))
          {
            if (mdd.GOutSpecType()[j].nelem())
            {
              if (count( mdd.GOutSpecType()[j].begin(),
                        mdd.GOutSpecType()[j].end(),
                        Workspace::wsv_data[wsv_key].Group() ) )
              {
                os << "<li>" << ds_insert_wsm_link(mdd.Name()) << endl;
                ++hitcount;
              }
            }
            else
            {
              os << "<li>" << ds_insert_wsm_link(mdd.Name()) << endl;
              ++hitcount;
            }
          }
        }
      }
    }
    if ( 0==hitcount ) os << "<li>none" << endl;
    
    os << endl << "</ul>" << endl;
    
    // List specific methods:
    hitcount = 0;
    os 
    << "<h3>Specific methods that can generate " << vname << "</h3>" << endl
    << "<ul>" << endl;
    for ( Index i=0; i<md_data_raw.nelem(); ++i )
    {
      // Get handle on method record:
      const MdRecord& mdd = md_data_raw[i];
      
      // This if statement checks whether Output, the list
      // of output variables contains the workspace
      // variable key.
      if ( count( mdd.Out().begin(),
                 mdd.Out().end(),
                 wsv_key ) ) 
      {
        os << "<li>" << ds_insert_wsm_link(mdd.Name()) << "\n";
        ++hitcount;
      }
    }
    if ( 0==hitcount ) os << "<li>none\n";
    
    os << endl << "</ul>" << endl;
    
    // List generic methods:
    hitcount = 0;
    os << "<h3>Generic and supergeneric methods that can use " << vname << "</h3>" << endl;
    os << "<ul>" << endl;
    for ( Index i=0; i<md_data_raw.nelem(); ++i )
    {
      // Get handle on method record:
      const MdRecord& mdd = md_data_raw[i];
      
      // This if statement checks whether GOutType, the list
      // of output variable types contains the group of the
      // requested variable.
      // The else clause picks up methods with supergeneric input.
      if ( count( mdd.GInType().begin(),
                 mdd.GInType().end(),
                 Workspace::wsv_data[wsv_key].Group() ) )
      {
        os << "<li>" << ds_insert_wsm_link(mdd.Name()) << endl;
        ++hitcount;
      }
      else if  ( count( mdd.GInType().begin(),
                       mdd.GInType().end(),
                       get_wsv_group_id("Any") ) )
      {
        for (Index j = 0; j < mdd.GInType().nelem(); j++)
        {
          if (mdd.GInType()[j] == get_wsv_group_id("Any"))
          {
            if (mdd.GInSpecType()[j].nelem())
            {
              if (count( mdd.GInSpecType()[j].begin(),
                        mdd.GInSpecType()[j].end(),
                        Workspace::wsv_data[wsv_key].Group() ) )
              {
                os << "<li>" << ds_insert_wsm_link(mdd.Name()) << endl;
                ++hitcount;
              }
            }
            else
            {
              os << "<li>" << ds_insert_wsm_link(mdd.Name()) << endl;
              ++hitcount;
            }
          }
        }
      }
    }
    if ( 0==hitcount ) os << "<li>none" << endl;
    
    os << endl << "</ul>" << endl;
    
    // List specific methods:
    hitcount = 0;
    os 
    << "<h3>Specific methods that require " << vname << "</h3>" << endl
    << "<ul>" << endl;
    for ( Index i=0; i<md_data_raw.nelem(); ++i )
    {
      // Get handle on method record:
      const MdRecord& mdd = md_data_raw[i];
      
      // This if statement checks whether Output, the list
      // of output variables contains the workspace
      // variable key.
      if ( count( mdd.In().begin(),
                 mdd.In().end(),
                 wsv_key ) ) 
      {
        os << "<li>" << ds_insert_wsm_link(mdd.Name()) << "\n";
        ++hitcount;
      }
    }
    if ( 0==hitcount ) os << "<li>none\n";
    
    os << endl << "</ul>" << endl;
    
    // List agendas with this variable as output:
    extern Array<AgRecord> agenda_data;
    hitcount = 0;
    os 
    << "<h3>Agendas that can generate " << vname << "</h3>" << endl
    << "<ul>" << endl;
    for ( Index i=0; i<agenda_data.nelem(); ++i )
    {
      // Get handle on method record:
      const AgRecord& ar = agenda_data[i];
      
      // This if statement checks whether Output, the list
      // of output variables contains the workspace
      // variable key.
      if ( count( ar.Out().begin(),
                 ar.Out().end(),
                 wsv_key ) ) 
      {
        os << "<li>" << ds_insert_agenda_link(ar.Name()) << "\n";
        ++hitcount;
      }
    }
    if ( 0==hitcount ) os << "<li>none\n";
    
    os << endl << "</ul>" << endl;
    
    // List agendas with this variable as input:
    hitcount = 0;
    os << "<h3>Agendas that require " << vname << "</h3>" << endl
    << "<ul>" << endl;
    for ( Index i=0; i<agenda_data.nelem(); ++i )
    {
      // Get handle on method record:
      const AgRecord& ar = agenda_data[i];
      
      // This if statement checks whether Output, the list
      // of output variables contains the workspace
      // variable key.
      if ( count( ar.In().begin(),
                 ar.In().end(),
                 wsv_key ) ) 
      {
        os << "<li>" << ds_insert_agenda_link(ar.Name()) << "\n";
        ++hitcount;
      }
    }
    
    if ( 0==hitcount ) os << "<li>none\n";
    
    os << endl << "</ul>" << endl;
  }
}

//! Output the workspace variable documentation to stream.
/** 
 Output the documentation for the given workspace variable to the stream in
 HTML formatting.
 
 \param[in,out]  os     Output stream.
 \param[in]      vname  Variable name.
 
 \author Oliver Lemke
 */
void ds_doc_variable (ostream &os, const string& vname)
{
  extern const ArrayOfString wsv_group_names;
  
  // Find wsv id:
  map<String, Index>::const_iterator it = Workspace::WsvMap.find(vname);
  if ( it != Workspace::WsvMap.end() )
  {
    // If we are here, then the given name matches a workspace
    // variable.
    os << "<pre>" << endl;
    for (String::const_iterator sit = Workspace::wsv_data[it->second].Description().begin();
         sit != Workspace::wsv_data[it->second].Description().end(); sit++)
    {
      os << ds_html_escape_char(*sit);
    }
    os << endl << "</pre>" << endl << endl;
    
    os << "<p><b>Group: </b>"
    << ds_insert_group_link(wsv_group_names[Workspace::wsv_data[it->second].Group()]) << endl;
  }

  ds_doc_variable_methods(os, vname);
}

//! Output the agenda documentation to stream.
/** 
 Output the documentation for the given agenda to the stream in
 HTML formatting.
 
 \param[in,out]  os     Output stream.
 \param[in]      aname  Agenda name.
 
 \author Oliver Lemke
 */
void ds_doc_agenda (ostream &os, const string& aname)
{
  extern const ArrayOfString wsv_group_names;
  
  // Find wsv id:
  map<String, Index>::const_iterator it = Workspace::WsvMap.find(aname);
  extern Array<AgRecord> agenda_data;
  extern const map<String, Index> AgendaMap;
  map<String, Index>::const_iterator ait = AgendaMap.find(aname);
  
  if ( it != Workspace::WsvMap.end() && ait != AgendaMap.end() )
  {
    // If we are here, then the given name matches a workspace
    // variable.
    os << "<pre>" << endl;
    for (String::const_iterator sit = agenda_data[ait->second].Description().begin();
         sit != agenda_data[ait->second].Description().end(); sit++)
    {
      os << ds_html_escape_char(*sit);
    }
    os << endl << "</pre>" << endl << endl;

    os << "<p><b>Group: </b>"
    << ds_insert_group_link(wsv_group_names[Workspace::wsv_data[it->second].Group()]) << endl;
    
    os << "<h3>Variables</h3>" << endl;
    
    // Out:
    if ( ait != AgendaMap.end() )
    {
      // If we are here, then the given name matches a method.
      const AgRecord& agr = agenda_data[ait->second];
      String indent = "";
      String desc;
      ostringstream buf;
      size_t linelen = 80;
      os << "<table>" << endl;
      for ( Index i=0; i<agr.Out().nelem(); ++i )
      {
        buf.str("");
        buf << "<tr>";
        buf <<    "<td>OUT</td>";
        
        {
          const String& vname = Workspace::wsv_data[agr.Out()[i]].Name();
          buf << "<td class=\"right\">" << ds_insert_wsv_link(vname) << "</td><td>(";
          buf << ds_insert_group_link(wsv_group_names[Workspace::wsv_data[agr.Out()[i]].Group()]);
          buf << ")</td><td>";
        }
        
        get_short_wsv_description(desc, ds_html_escape_string(Workspace::wsv_data[agr.Out()[i]].Description()));
        
        if (buf.str().length() + desc.length() > linelen)
        {
          format_paragraph (desc, indent, linelen);
          buf << endl << indent << desc;
        }
        else
        {
          buf << desc;
        }
        
        os << buf.str() << "</td></tr>" << endl;
        
      }
      
      for ( Index i=0; i<agr.In().nelem(); ++i )
      {
        buf.str("");
        buf << "<tr>";
        buf <<    "<td>IN</td>";
        
        const String& vname = Workspace::wsv_data[agr.In()[i]].Name();
        buf << "<td class=\"right\">" << ds_insert_wsv_link(vname);
        buf << "</td><td>(";
        buf << ds_insert_group_link(wsv_group_names[Workspace::wsv_data[agr.In()[i]].Group()]);
        buf << ")</td><td>";
        
        get_short_wsv_description(
                                  desc, ds_html_escape_string(Workspace::wsv_data[agr.In()[i]].Description()));
        
        if (buf.str().length() + desc.length() > linelen)
        {
          format_paragraph (desc, indent, linelen, indent.length());
          buf << endl << indent << desc;
        }
        else
        {
          buf << desc;
        }
        
        os << buf.str() << "</td></tr>" << endl;
      }
      
      os << "</table>" << endl;
    }
  }

  ds_doc_variable_methods(os, aname);
}

//! Output the workspace group documentation to stream.
/** 
 Output the documentation for the given workspace group to the stream in
 HTML formatting.
 
 \param[in,out]  os     Output stream.
 \param[in]      gname  Group name.
 
 \author Oliver Lemke
 */
void ds_doc_group (ostream &os, const string& gname)
{
  // Check if the user gave the name of a specific variable.
  Index gid = get_wsv_group_id (gname);
  extern const Array<MdRecord>  md_data_raw;
  if ( gid != -1 )
  {
    // If we are here, then the given name matches a group.

    // List generic methods:
    Index hitcount = 0;
    os << "<h3>Generic and supergeneric methods that can generate " << gname << "</h3>" << endl;
    os << "<ul>" << endl;
    for ( Index i=0; i<md_data_raw.nelem(); ++i )
    {
      // Get handle on method record:
      const MdRecord& mdd = md_data_raw[i];
      
      // This if statement checks whether GOutType, the list
      // of output variable types contains the group of the
      // requested variable.
      // The else clause picks up methods with supergeneric input.
      if ( count( mdd.GOutType().begin(), mdd.GOutType().end(), gid ) )
      {
        os << "<li>" << ds_insert_wsm_link(mdd.Name()) << endl;
        ++hitcount;
      }
      else if  ( count( mdd.GOutType().begin(),
                       mdd.GOutType().end(),
                       get_wsv_group_id("Any") ) )
      {
        for (Index j = 0; j < mdd.GOutType().nelem(); j++)
        {
          if (mdd.GOutType()[j] == get_wsv_group_id("Any"))
          {
            if (mdd.GOutSpecType()[j].nelem())
            {
              if (count( mdd.GOutSpecType()[j].begin(),
                        mdd.GOutSpecType()[j].end(),
                        gid ) )
              {
                os << "<li>" << ds_insert_wsm_link(mdd.Name()) << endl;
                ++hitcount;
              }
            }
            else
            {
              os << "<li>" << ds_insert_wsm_link(mdd.Name()) << endl;
              ++hitcount;
            }
          }
        }
      }
    }
    if ( 0==hitcount ) os << "<li>none" << endl;
    
    os << endl << "</ul>" << endl;

    hitcount = 0;
    os << "<h3>Generic and supergeneric methods that can use " << gname << "</h3>" << endl;
    os << "<ul>" << endl;
    for ( Index i=0; i<md_data_raw.nelem(); ++i )
    {
      // Get handle on method record:
      const MdRecord& mdd = md_data_raw[i];
      
      // This if statement checks whether GOutType, the list
      // of output variable types contains the group of the
      // requested variable.
      // The else clause picks up methods with supergeneric input.
      if ( count( mdd.GInType().begin(), mdd.GInType().end(), gid ) )
      {
        os << "<li>" << ds_insert_wsm_link(mdd.Name()) << endl;
        ++hitcount;
      }
      else if  ( count( mdd.GInType().begin(),
                       mdd.GInType().end(),
                       get_wsv_group_id("Any") ) )
      {
        for (Index j = 0; j < mdd.GInType().nelem(); j++)
        {
          if (mdd.GInType()[j] == get_wsv_group_id("Any"))
          {
            if (mdd.GInSpecType()[j].nelem())
            {
              if (count( mdd.GInSpecType()[j].begin(),
                        mdd.GInSpecType()[j].end(),
                        gid ) )
              {
                os << "<li>" << ds_insert_wsm_link(mdd.Name()) << endl;
                ++hitcount;
              }
            }
            else
            {
              os << "<li>" << ds_insert_wsm_link(mdd.Name()) << endl;
              ++hitcount;
            }
          }
        }
      }
    }
    if ( 0==hitcount ) os << "<li>none" << endl;
    
    os << endl << "</ul>" << endl;

    if (gname != "Any")
    {
      // List specific methods:
      hitcount = 0;
      os << "<h3>Specific methods that can generate " << gname << "</h3>" << endl;
      os << "<ul>" << endl;
      for ( Index i=0; i<md_data_raw.nelem(); ++i )
      {
        // Get handle on method record:
        const MdRecord& mdd = md_data_raw[i];
        
        bool first = true;
        for ( Index j=0; j<mdd.Out().nelem(); j++)
        {
          // This if statement checks whether the type of this output variable
          // matches this group.
          if (Workspace::wsv_data[mdd.Out()[j]].Group() == gid)
          {
            if (first)
            {
              first = false;
              os << "<li>" << ds_insert_wsm_link(mdd.Name()) << " (";
            }
            else
              os << ", ";
            os << ds_insert_wsv_link(Workspace::wsv_data[mdd.Out()[j]].Name());
            
            ++hitcount;
          }
        }
        if (!first) os << ")" << endl;
      }
      if ( 0==hitcount ) os << "<li>none" << endl;
      
      os << endl << "</ul>" << endl;
      
      hitcount = 0;
      os << "<h3>Specific methods that require variables of group " << gname << "</h3>" << endl;
      os << "<ul>" << endl;
      for ( Index i=0; i<md_data_raw.nelem(); ++i )
      {
        // Get handle on method record:
        const MdRecord& mdd = md_data_raw[i];
        
        bool first = true;
        for ( Index j=0; j<mdd.In().nelem(); j++)
        {
          // This if statement checks whether the type of this output variable
          // matches this group.
          if (Workspace::wsv_data[mdd.In()[j]].Group() == gid)
          {
            if (first)
            {
              first = false;
              os << "<li>" << ds_insert_wsm_link(mdd.Name()) << " (";
            }
            else
              os << ", ";
            os << ds_insert_wsv_link(Workspace::wsv_data[mdd.In()[j]].Name());
            
            ++hitcount;
          }
        }
        if (!first) os << ")" << endl;
      }
      if ( 0==hitcount ) os << "<li>none" << endl;
      
      os << endl << "</ul>" << endl;
      
      Index i;
      
      os << "<h3>Workspace Variables of group " << gname << "</h3>" << endl
      << "<ul>" << endl;
      
      hitcount = 0;
      for ( i=0; i<Workspace::wsv_data.nelem(); ++i )
      {
        if (Workspace::wsv_data[i].Group() == get_wsv_group_id(gname))
        {
          os << "<li>" << ds_insert_wsv_link(Workspace::wsv_data[i].Name()) << endl;
          hitcount++;
        }
      }
      if ( 0==hitcount ) os << "<li>none" << endl;
      
      os << "</ul>" << endl;
    }
  }
}

//! Output HTML code for a breadcrumb token.
/** 
 Output the HTML code for the token with the given id. Used for the
 navigation at the top of each docserver page.
 
 \param[in,out]  os         Output stream.
 \param[in]      tokens     List of tokens.
 \param[in]      token_id   Id of the desired token.
 
 \author Oliver Lemke
 */
void ds_insert_breadcrumb_token (ostream& os, const vector<string>& tokens,
                                 size_t token_id)
{
  bool link = (token_id < tokens.size()-1);
  
  if (link)
  {
    os << "<a href=\"" << ds_baseurl;
    for (size_t t = 0; t <= token_id; t++)
    {
      if (t != 1) os << "/";
      os << tokens[t];
    }
    os << "\">";
  }

  if (!token_id) os << "Home";
  else if (tokens[token_id] == "methods") os << "Methods";
  else if (tokens[token_id] == "variables") os << "Variables";
  else if (tokens[token_id] == "agendas") os << "Agendas";
  else if (tokens[token_id] == "groups") os << "Groups";
  else os << tokens[token_id];
  
  if (link) os << "</a>";
}

//! Output HTML code for breadcrumbs.
/** 
 Output the HTML code for breadcrumbs based on the give tokens. Used for the
 navigation at the top of each docserver page.
 
 \param[in,out]  os         Output stream.
 \param[in]      tokens     List of tokens.
 
 \author Oliver Lemke
 */
void ds_insert_breadcrumbs (ostream& os, const vector<string>& tokens)
{
  vector<string> ntokens = tokens;
  ntokens.insert(ntokens.begin(), "");
  os << "<span class=\"breadcrumbs\">";
  for (size_t t = 0; t < ntokens.size(); t++)
  {
    if (t) os << "&nbsp;>>&nbsp;";
    ds_insert_breadcrumb_token (os, ntokens, t);
  }
  os << "</span>" << endl;
}

//! Output H1 HTML tag.
/** 
 Formats the title string as an H1 header.
 
 \param[in,out]  os     Output stream.
 \param[in]      title  Title string.
 
 \author Oliver Lemke
 */
void ds_insert_title (ostream& os, const string& title = "")
{
  os << "<h1>"DOCSERVER_NAME;
  if (title.length())
    os << " &mdash; " << title;
  os << "</h1>" << endl;
}

//! Output an HTML index of the workspace members.
/** 
 Output depending on the tokens either a list of workspace methods, variables,
 agendas or groups. Or if tokens is empty, a list of all of them.
 
 \param[in,out]  os       Output stream.
 \param[in]      tokens   Tokens with the current position in the docserver
                          hierarchy.
 
 \author Oliver Lemke
 */
void ds_insert_index (ostream& os, const vector<string>& tokens)
{
  void(*index_method)(ostream&);
  string title;
  
  if (tokens.size() == 0)
  {
    ds_insert_breadcrumbs (os, tokens);
    ds_insert_title (os, "Index");
    
    os
    << "<p>Jump to: <a href=\"#methods\">Methods</a>&nbsp;-&nbsp;"
    << "<a href=\"#variables\">Variables</a>&nbsp;-&nbsp;"
    << "<a href=\"#agendas\">Agendas</a>&nbsp;-&nbsp;"
    << "<a href=\"#groups\">Groups</a>"
    << endl;
    
    os << "<table class=\"list\">" << endl;
    ds_list_methods (os);
    ds_list_variables (os);
    ds_list_agendas (os);
    ds_list_groups (os);
    os << "</table>" << endl;
    return;
  }
  else if (tokens[0] == "methods")
  {
    title = "Workspace Method Index";
    index_method = ds_list_methods;
  }
  else if (tokens[0] == "variables")
  {
    title = "Workspace Variable Index";
    index_method = ds_list_variables;
  }
  else if (tokens[0] == "groups")
  {
    title = "Workspace Group Index";
    index_method = ds_list_groups;
  }
  else if (tokens[0] == "agendas")
  {
    title = "Agenda Index";
    index_method = ds_list_agendas;
  }
  else return;

  ds_insert_breadcrumbs (os, tokens);
  ds_insert_title (os, title);
  os << "<table class=\"list\">" << endl;
  (*index_method)(os);
  os << "</table>" << endl;
}

//! Output HTML documentation of a workspace member.
/** 
 Output depending on the tokens the documentation of a workspace method,
 variable, agenda or group.
 
 \param[in,out]  os       Output stream.
 \param[in]      tokens   Tokens with the current position in the docserver
                          hierarchy.
 
 \author Oliver Lemke
 */
void ds_insert_doc (ostream& os, const vector<string>& tokens)
{
  void(*doc_method)(ostream&, const string&);
  string title;
  
  if (tokens[0] == "methods")
  {
    title = "Workspace Method " + tokens[1];
    doc_method = ds_doc_method;
  }
  else if (tokens[0] == "variables")
  {
    title = "Workspace Variable " + tokens[1];
    doc_method = ds_doc_variable;
  }
  else if (tokens[0] == "groups")
  {
    title = "Workspace Group " + tokens[1];
    doc_method = ds_doc_group;
  }
  else if (tokens[0] == "agendas")
   {
   title = "Agenda " + tokens[1];
   doc_method = ds_doc_agenda;
   }
  else return;
  
  ds_insert_breadcrumbs (os, tokens);
  ds_insert_title (os);
  os << "<h2>" << title << "</h2>" << endl;
  
  (*doc_method)(os, tokens[1]);
}

//! Output docserver stylesheet.
/** 
 Outpus the docserver stylesheet to the stream.
 
 \param[in,out]  os     Output stream.
 
 \author Oliver Lemke
 */
void ds_stylesheet (ostream& os)
{
  os
  << "body { font-family: monospace }" << endl
  << "a:link { color: #3465a4; text-decoration: underline; }" << endl
  << "a:visited { color: #729fcf; text-decoration: underline; }" << endl
  << "a:active { color: #ce5c00; text-decoration: underline; background-color: #eeeeec}" << endl
  << "a:hover { color: #f57900; text-decoration: underline; }" << endl
  
  << "table.list {" << endl
  << "width: 90%;" << endl
  << "margin-left: 5%;" << endl
  << "margin-right: 5%;" << endl
  << "}" << endl

  << "table {" << endl
  << "border-width: 0px;" << endl
  << "}" << endl

  << "table td {" << endl
  << "vertical-align: top;" << endl
  << "}" << endl
  
  << "table td.right {" << endl
  << "text-align: right;" << endl
  << "}" << endl
  
  << "span.breadcrumbs {" << endl
  << "font-size: small;" << endl
  << "}" << endl
  
  << "div.footer {" << endl
  << "margin-top: 2.5em;" << endl
  << "text-align: right;" << endl
  << "color: #aaaaa8;" << endl
  << "font-size: small;" << endl
  << "}" << endl
  
  << endl;
}

//! HTML request responder.
/** 
 Callback function to serve the HTML pages. Based on an example from the
 libmicrohttpd library.
 
 \param[in,out]   cls               Unused parameter.
 \param[in,out]   connection        Connection info.
 \param[in]       url               Requested URL.
 \param[in]       method            Request method, must be GET.
 \param[in]       version           Unused parameter.
 \param[in]       upload_data       Unused parameter.
 \param[in]       upload_data_size  Unused parameter.
 \param[in,out]  ptr                Call state.
 
 \returns Status code.
 
 \author Oliver Lemke
 \date   <#date#>
 */
static int
ahc_echo (void *cls _U_,
          struct MHD_Connection *connection,
          const char *url,
          const char *method,
          const char *version _U_,
          const char *upload_data _U_,
          size_t *upload_data_size _U_,
          void **ptr)
{
  static int aptr;
  const char *val;
  string surl(url);
  struct MHD_Response *response;
  int ret;
  
  if (0 != strcmp (method, "GET"))
  {
    out0 << "Docserver error: Unexpected method " << method << "\n";
    return MHD_NO;              /* unexpected method */
  }
  if (&aptr != *ptr)
  {
    /* do never respond on first call */
    *ptr = &aptr;
    return MHD_YES;
  }
  *ptr = NULL;                  /* reset when done */
  val = MHD_lookup_connection_value (connection, MHD_GET_ARGUMENT_KIND, "q");
  
  ostringstream hout;
  
  if (surl.find(ds_baseurl) == 0)
  {
    surl.erase(0, ds_baseurl.size());
  }
  
  vector<string> tokens;
  split (surl, '/', tokens);
 
  while (tokens.size() && tokens[tokens.size()-1] == "")
    tokens.erase(tokens.end());
      
  while (tokens.size() && tokens[0] == "")
    tokens.erase(tokens.begin());
  
  string content_type = "text/html; charset=utf-8";
  if (tokens.size() && tokens[tokens.size()-1] == "styles.css")
  {
    ds_stylesheet(hout);
    content_type = "text/css; charset=utf-8";
  }
  else
  {
    ds_begin_page (hout);
    
    switch (tokens.size())
    {
      case 0:
      case 1:
        ds_insert_index (hout, tokens);
        break;
      case 2:
        ds_insert_doc(hout, tokens);
        break;
      default:
        ds_insert_title (hout);
    }
    
    ds_end_page (hout);
  }
  
  response = MHD_create_response_from_data (hout.str().length(),
                                            (void *)hout.str().c_str(),
                                            MHD_NO, MHD_YES);
  
  if (response == NULL) {
    out0 << "Docserver error: response = 0\n";
    return MHD_NO;
  }

  MHD_add_response_header (response, "Content-type", content_type.c_str());
  ret = MHD_queue_response (connection, MHD_HTTP_OK, response);
  MHD_destroy_response (response);
  
  return ret;
}

//! Starts docserver.
/** 
 Starts the HTTP server daemon.
 
 \param[in]  port     Port to listen on.
 \param[in]  daemon   Flag to run as daemon or in the foreground.
 \param[in]  baseurl  URL to prepend to all links.
 
 \returns Status code.
 
 \author Oliver Lemke
 */
int docserver_start(Index port, bool daemon, const string& baseurl)
{
  struct MHD_Daemon *d;
  
  ds_baseurl = baseurl;
  
  if (port == -1) port=9000;
  d = MHD_start_daemon (MHD_USE_THREAD_PER_CONNECTION | MHD_USE_DEBUG,
                        port, NULL, NULL, &ahc_echo, NULL, MHD_OPTION_END);
  
  if (d == NULL)
  {
    out0 << "Error: Cannot start server. Maybe port " << port << " is already in use?\n"; 
    return 1;
  }
  else
  {
    if (daemon)
      out0 << "ARTS docserver listening at http://localhost:" << port << "\n";
    else
      out0 << "\n"
      << "===========================================================\n"
      << "Now point your web browser to http://localhost:" << port << "\n"
      << "===========================================================\n\n"
      << "Press enter to exit.\n";
  }
  
  
  if (daemon)
  {
    pause();
  }
  else
  {
    (void) getc (stdin);
    out0 << "Stopping docserver.\n";
    MHD_stop_daemon (d);
    out0 << "Goodbye.\n";
  }
  return 0;
}


