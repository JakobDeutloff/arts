/* Input / Output method functions. */

#include "arts.h"
#include "messages.h"
#include "file.h"
#include "vecmat.h"
#include "math_funcs.h"
#include "md.h"


//
//----------------------------< Help functions >----------------------------
//

/** A helper function that writes an array of matrix to a stream. This
    is the generic output function for VECTORs, MATRIXs, and ARRAYof
    both. All these are converted first to ARRAYofMATRIX, and then
    written by this function.

    @param os   Output. The stream to write to.
    @param am    The matrix to write.

    @author Stefan Buehler */
void write_array_of_matrix_to_stream(ostream& os,
                                     const ARRAYofMATRIX& am)
{
  extern const string full_name;

  // Determine the precision, depending on whether Numeric is double
  // or float:  
  int precision;
  switch (sizeof(Numeric)) {
  case sizeof(float)  : precision = FLT_DIG; break;
  case sizeof(double) : precision = DBL_DIG; break;
  default: out0 << "Numeric must be double or float\n"; exit(1);
  }

  os << "# Generated by "
     << full_name << ", "
     << __DATE__ << ", "
     << __TIME__ << "\n";

  // Number of array elements:
  const size_t n = am.dim();
  os << n << '\n';

  for (size_t i=0; i<n; ++i)
    {
      // Number of elements:
      os << am[i].dim(1) << ' ' << am[i].dim(2) << '\n';

      os << setprecision(precision);
      // Write the elements:
      for (size_t r=0; r<am[i].dim(1); ++r)
        {
          os << am[i][r][0];
      
          for (size_t c=1; c<am[i].dim(2); ++c)
            {
              os << " " << am[i][r][c];
            }

          os << '\n';
        }
    }
}


/** A helper function that writes an array of matrix to a file. Uses
    write_array_of_matrix_to_stream. 

    @param filename    The name of the file.
    @param am          The array of matrix to write.

    @author Stefan Buehler */
void write_array_of_matrix_to_file(const string& filename,
                                   const ARRAYofMATRIX& am)
{
  ofstream of;

  out2 << "  Writing file: " << filename << '\n';
  open_output_file(of, filename);

  // Write the array of matrix to the stream:
  write_array_of_matrix_to_stream(of,am);
}


/** A helper function that reads an array of matrix from a stream.

    @param am   Output. The array of matrix to read.
    @param is   Output. The input stream.

    @author Stefan Buehler */
void read_array_of_matrix_from_stream(ARRAYofMATRIX& am,
                                      istream& is)
{
  // First, skip all the lines that have a # at the beginning. (Maybe
  // preceded by whitespace.)
  bool comments=true;
  char c;
  string linebuffer;
  while (comments)
    {
      is >> ws;
      is.get(c);
      if ('#'==c)
        {
          getline(is,linebuffer);
          //      cout << "C: " << linebuffer << endl;
        }
      else
        {
          is.unget();
          comments = false;
        }
    }

  // Read the array of matrix. The TNT package expects exactly this input
  // format.
  // For ARRAY: First one number indicating the dimension, then the
  // elements. 
  // For MATRIX: First two numbers indicating the dimensions, then the
  // elements. 
  is >> am;

  if ( is.fail() || is.bad() )
    throw runtime_error("Stream gave fail or bad.");

  is >> ws;

  if ( !is.eof() )
    throw runtime_error("Input finished, but end of stream not reached.");
}


/** A helper function that reads an array of matrix from a file. 
    Uses read_array_of_matrix_from_stream.

    @param am        Output. The array of matrix to read.
    @param filename  The name of the file to read.

    @author Stefan Buehler */
void read_array_of_matrix_from_file(ARRAYofMATRIX& am,
                                    const string& filename)
{
  ifstream ifs;

  // Open input stream:
  open_input_file(ifs, filename);
  // No need to check for error, because open_input_file throws a
  // runtime_error with an appropriate error message.

  // Read the matrix from the stream. Here we catch the exception,
  // because then we can issue a nicer error message that includes the 
  // filename.
  try
    {
      read_array_of_matrix_from_stream(am,ifs);
    }
  catch (runtime_error x)
    {
      ostringstream os;
      os << "Error reading file: " << filename << '\n'
         << x.what();
      throw runtime_error(os.str());
    }
}



//
//-------------------< Scalar initialization >--------------------------
//

void IntSet(// WS Generic Output:
            int& x,
            // WS Generic Output Names:
            const string& x_name,
            // Control Parameters:
            const int& value)
{
  x = value;
  out3 << "Setting " << x_name << " to " << value << ".\n";
}

void NumericSet(// WS Generic Output:
                Numeric& x,
                // WS Generic Output Names:
                const string& x_name,
                // Control Parameters:
                const Numeric& value)
{
  x = value;
  out3 << "Setting " << x_name << " to " << value << ".\n";
}



//
//------------------------< Vector initialization >------------------------
//

void VectorSet(           VECTOR&  x, 
                    const string&  x_name,
                    const int& n,
                    const Numeric& value )
{
  x.newsize(n);
  x = value;
  out3 << "  Creating " << x_name << " as a constant vector\n"; 
  out3 << "         length: " << n << "\n";
  out3 << "          value: " << value << "\n";
}

void VectorLinSpace(      VECTOR&  x, 
                    const string&  x_name,
                    const Numeric& start,
                    const Numeric& stop,
                    const Numeric& step )
{
  x = linspace(start,stop,step);
  out3 << "  Creating " << x_name << " as linearly spaced vector\n";
  out3 << "         length: " << x.size() << "\n";
  out3 << "    first value: " << x(1) << "\n";
  if ( x.size() > 1 )
  {
    out3 << "      step size: " << x(2)-x(1) << "\n";
    out3 << "     last value: " << x(x.size()) << "\n";
  }
}

void VectorNLinSpace(     VECTOR&  x, 
                    const string&  x_name,
                    const Numeric& start,
                    const Numeric& stop,
                    const int& n )
{
  x = nlinspace(start,stop,n);
  out3 << "  Creating " << x_name << " as linearly spaced vector\n";
  out3 << "         length: " << n << "\n";
  out3 << "    first value: " << x(1) << "\n";
  if ( x.size() > 1 )
  {
    out3 << "      step size: " << x(2)-x(1) << "\n";
    out3 << "     last value: " << x(x.size()) << "\n";
  }
}

void VectorNLogSpace(     VECTOR&  x, 
                    const string&  x_name,
                    const Numeric& start,
                    const Numeric& stop,
                    const int& n )
{
  x = nlogspace(start,stop,n);
  out3 << "  Creating " << x_name << " as logarithmically spaced vector\n";
  out3 << "         length: " << n << "\n";
  out3 << "    first value: " << x(1) << "\n";
  if ( x.size() > 1 )
    out3 << "     last value: " << x(x.size()) << "\n";
}



//
//--------------------< Array of Matrix and Array of Vector Write Methods >--------------------
//

void ArrayOfMatrixWriteToFile(// WS Generic Input:
                              const ARRAYofMATRIX& am,
                              // WS Generic Input Names:
                              const string& am_name)
{
  extern const string basename;                       
  string filename = basename+"."+am_name+".a";

  // Write the array of matrix to the file.
  write_array_of_matrix_to_file(filename,am);
}

void ArrayOfMatrixWriteToNamedFile(// WS Generic Input:
                                   const ARRAYofMATRIX& am,
                                   // WS Generic Input Names:
                                   const string& am_name,
                                   // Control Parameters:
                                   const string& filename)
{

  // Write the array of matrix to the file.
  write_array_of_matrix_to_file(filename,am);
}

void ArrayOfVectorWriteToFile(// WS Generic Input:
                              const ARRAYofVECTOR& av,
                              // WS Generic Input Names:
                              const string& av_name)
{
  extern const string basename;                       
  string filename = basename+"."+av_name+".a";

  // Convert the array of vector to an array of matrix:
  ARRAYofMATRIX am(av.dim());
  for (size_t i=0; i<av.dim(); ++i)
    {
      to_matrix(am[i],av[i]);
    }

  // Write the array of matrix to the file.
  write_array_of_matrix_to_file(filename,am);
}

void ArrayOfVectorWriteToNamedFile(// WS Output:
                                   const ARRAYofVECTOR& av,
                                   // WS Variable Names:
                                   const string& av_name,
                                   // Control Parameters:
                                   const string& filename)
{

  // Convert the array of vector to an array of matrix:
  ARRAYofMATRIX am(av.dim());
  for (size_t i=0; i<av.dim(); ++i)
    {
      to_matrix(am[i],av[i]);
    }

  // Write the array of matrix to the file.
  write_array_of_matrix_to_file(filename,am);
}


//
//--------------------< Matrix and Vector Write Methods >--------------------
//

void MatrixWriteToFile(// WS Generic Input:
                       const MATRIX& m,
                       // WS Generic Input Names:
                       const string& m_name)
{
  extern const string basename;                       
  string filename = basename+"."+m_name+".a";

  // Convert the matrix to an array of matrix:
  ARRAYofMATRIX am(1,m);

  // Write the array of matrix to the file.
  write_array_of_matrix_to_file(filename,am);
}

void MatrixWriteToNamedFile(// WS Generic Input:
                            const MATRIX& m,
                            // WS Generic Input Names:
                            const string& m_name,
                            // Control Parameters:
                            const string& filename)
{

  // Convert the matrix to an array of matrix:
  ARRAYofMATRIX am(1,m);

  // Write the array of matrix to the file.
  write_array_of_matrix_to_file(filename,am);
}

void VectorWriteToFile(// WS Generic Input:
                       const VECTOR& v,
                       // WS Generic Input Names:
                       const string& v_name)
{
  extern const string basename;                       
  string filename = basename+"."+v_name+".a";

  // Convert the vector to a matrix:
  MATRIX m;
  to_matrix(m,v);

  // Convert the matrix to an array of matrix:
  ARRAYofMATRIX am(1,m);

  // Write the array of matrix to the file.
  write_array_of_matrix_to_file(filename,am);
}

void VectorWriteToNamedFile(// WS Output:
                            const VECTOR& v,
                            // WS Variable Names:
                            const string& v_name,
                            // Control Parameters:
                            const string& filename)
{

  // Convert the vector to a matrix:
  MATRIX m;
  to_matrix(m,v);

  // Convert the matrix to an array of matrix:
  ARRAYofMATRIX am(1,m);

  // Write the array of matrix to the file.
  write_array_of_matrix_to_file(filename,am);
}



//
//--------------------< Array of Matrix and Array of Vector Read Methods >--------------------
//

void ArrayOfVectorReadFromFile(// WS Generic Output:
                               ARRAYofVECTOR& av,
                               // WS Generic Output Names:
                               const string& av_name)
{
  extern const string basename;                       
  string filename = basename+"."+av_name+".a";

  // Read an array of matrix from the file:
  ARRAYofMATRIX am;
  read_array_of_matrix_from_file(am,filename);

  // Convert the array of matrix to an array of vector.
  av.newsize(am.dim());
  for (size_t i=0; i<am.dim(); ++i)
    {
      to_vector(av[i],am[i]);
    }
}

void ArrayOfMatrixReadFromFile(// WS Generic Output:
                               ARRAYofMATRIX& am,
                               // WS Generic Output Names:
                               const string& am_name)
{
  extern const string basename;                       
  string filename = basename+"."+am_name+".a";

  // Read the array of matrix from the file:
  read_array_of_matrix_from_file(am,filename);
}



//
//--------------------< Matrix and Vector Read Methods >--------------------
//

void VectorReadFromFile(// WS Generic Output:
                        VECTOR& v,
                        // WS Generic Output Names:
                        const string& v_name)
{
  extern const string basename;                       
  string filename = basename+"."+v_name+".a";

  // Read an array of matrix from the file:
  ARRAYofMATRIX am;
  read_array_of_matrix_from_file(am,filename);

  // Convert the array of matrix to a matrix.
  if ( 1 != am.dim() )
    throw runtime_error("You tried to convert an array of matrix to a matrix,\n"
                        "but the dimension of the array is not 1.");
  MATRIX m(am[0]);

  // Convert the matrix to a vector:
  to_vector(v,m);
}

void MatrixReadFromFile(// WS Generic Output:
                        MATRIX& m,
                        // WS Generic Output Names:
                        const string& m_name)
{
  extern const string basename;                       
  string filename = basename+"."+m_name+".a";

  // Read the array of matrix from the file:
  ARRAYofMATRIX am;
  read_array_of_matrix_from_file(am,filename);

  // Convert the array of matrix to a matrix.
  if ( 1 != am.dim() )
    throw runtime_error("You tried to convert an array of matrix to a matrix,\n"
                        "but the dimension of the array is not 1.");

  m = am[0];
}







