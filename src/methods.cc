/*-----------------------------------------------------------------------
FILE:      methods.cc

INCLUDES:  This file contains only the function define_md_data, which
           sets the WSV lookup data. You have to change this function
	   each time you add a new method. See methods.h for more
	   documentation. 

GLOBALS:   None defined

FUNCTIONS: void define_md_data()

HISTORY:   10.06.2000 Created by Stefan Buehler
-----------------------------------------------------------------------*/
/* Implementation of MdRecord and of the compound to hold the
   records. See methods.h for more documentation. */

#include "arts.h"
#include "make_array.h"
#include "workspace.h"
#include "methods.h"


void define_md_data()
{
  // The variable md_data is defined in file methods_aux.cc.
  extern ARRAY<MdRecord> md_data;

  // Initialize to zero, just in case:
  md_data.clear();

  /* Here's an empty template record entry:

  md_data.push_back
    ( MdRecord
      ( NAME(""),
	DESCRIPTION(""),
	OUTPUT(),
	INPUT(),
	GOUTPUT(),
	GINPUT(),
	KEYWORDS(""),
	TYPES()
	));
  */


//======================================================================
//=== IO methods
//======================================================================

//
//=== Scalars
//
  md_data.push_back
    ( MdRecord
      ( NAME("IntSet"),
	DESCRIPTION("Sets an integer workspace variable to the given value."),
	OUTPUT(),
	INPUT(),
	GOUTPUT(int_t),
	GINPUT(),
	KEYWORDS("value"),
	TYPES(int_t)));

  md_data.push_back
    ( MdRecord
      ( NAME("NumericSet"),
	DESCRIPTION("Sets a workspace variable of type Numeric to a value."),
	OUTPUT(),
	INPUT(),
	GOUTPUT(Numeric_),
	GINPUT(),
	KEYWORDS("value"),
	TYPES(Numeric_t)));



//
//=== Vector initialization
//

  md_data.push_back
    ( MdRecord
      ( NAME("VectorSet"),
	DESCRIPTION("Creates a workspace vector with the specified length\n"
                    "and initializes the vector with the given value."),
	OUTPUT(),
	INPUT(),
	GOUTPUT(VECTOR_),
	GINPUT(),
	KEYWORDS("length", "value"),
	TYPES(int_t, Numeric_t)));

  md_data.push_back
    ( MdRecord
      ( NAME("VectorLinSpace"),
	DESCRIPTION("Creates a linearly spaced vector with defined spacing.\n"
                    "Format: VectorLinSpace(x){start,stop,step}\n"
		    "The first element of x is always start.\n"
		    "The next value is start+step etc.\n"
		    "Note that the last value can deviate from stop.\n"
		    "The step can be both positive and negative."),
	OUTPUT(),
	INPUT(),
	GOUTPUT(VECTOR_),
	GINPUT(),
	KEYWORDS("start", "stop", "step"),
	TYPES(Numeric_t, Numeric_t, Numeric_t)));

  md_data.push_back
    ( MdRecord
      ( NAME("VectorNLinSpace"),
	DESCRIPTION("Creates a vector with defined length, equally spaced\n"
                    "between the given values.\n"
		    "The length must be larger than 1."),
	OUTPUT(),
	INPUT(),
	GOUTPUT(VECTOR_),
	GINPUT(),
	KEYWORDS("start", "stop", "n"),
	TYPES(Numeric_t, Numeric_t, int_t)));

  md_data.push_back
    ( MdRecord
      ( NAME("VectorNLogSpace"),
	DESCRIPTION("Creates a vector with defined length, logarithmically\n"
                    "spaced between the given values.\n"
		    "The length must be larger than 1."),
	OUTPUT(),
	INPUT(),
	GOUTPUT(VECTOR_),
	GINPUT(),
	KEYWORDS("start", "stop", "n"),
	TYPES(Numeric_t, Numeric_t, int_t)));


  //
  //=== Array of Matrix and Array of Vector Write Methods
  //
  md_data.push_back
    ( MdRecord
      ( NAME("ArrayOfMatrixWriteToFile"),
	DESCRIPTION("Writes a variable of this type to a file.\n"
		    "The filename can also be an empty string.\n"
		    "In that case the name is set to <basename>.<variable_name>.am.\n"
		    "The format is as follows:\n\n"
		    "# <comments>\n"
		    "<n_array_elements>\n"
		    "<n_rows> <n_columns>\n"
		    "<elements>\n"
		    "<n_rows> <n_columns>\n"
		    "<elements>\n"
		    "...\n\n"
		    "Example:\n"
		    "# Generated by arts-0.0.16, Apr 29 2000, 17:38:44\n"
		    "2\n"
		    "3 4\n"
		    "xx xx xx xx\n"
		    "xx xx xx xx\n"
		    "xx xx xx xx\n"
		    "2 2\n"
		    "yy yy\n"
		    "yy yy"),
	OUTPUT(),
	INPUT(),
	GOUTPUT(),
	GINPUT(ARRAYofMATRIX_),
	KEYWORDS( "filename" ),
	TYPES(    string_t   )));

  md_data.push_back
    ( MdRecord
      ( NAME("ArrayOfVectorWriteToFile"),
	DESCRIPTION("Writes a variable of this type to a file.\n"
		    "The filename can be specified or an empty string.\n"
		    "See `ArrayOfMatrixWriteToFile' for more details."),
	OUTPUT(),
	INPUT(),
	GOUTPUT(),
	GINPUT(ARRAYofVECTOR_),
	KEYWORDS( "filename" ),
	TYPES(    string_t   )));



//
//=== Matrix and Vector Write Methods
//
  md_data.push_back
    ( MdRecord
      ( NAME("MatrixWriteToFile"),
	DESCRIPTION("Writes a variable of this type to a file.\n"
		    "The filename can be specified or an empty string.\n"
		    "See `ArrayOfMatrixWriteToFile' for more details."),
	OUTPUT(),
	INPUT(),
	GOUTPUT(),
	GINPUT(MATRIX_),
	KEYWORDS( "filename" ),
	TYPES(    string_t   )));

  md_data.push_back
    ( MdRecord
      ( NAME("VectorWriteToFile"),
	DESCRIPTION("Writes a variable of this type to a file.\n"
		    "The filename can be specified or an empty string.\n"
		    "See `ArrayOfMatrixWriteToFile' for more details."),
	OUTPUT(),
	INPUT(),
	GOUTPUT(),
	GINPUT(VECTOR_),
	KEYWORDS( "filename" ),
	TYPES(    string_t   )));



//
//=== Array of Matrix and Vector Read Methods
//
  md_data.push_back
    ( MdRecord
      ( NAME("ArrayOfMatrixReadFromFile"),
	DESCRIPTION("Writes a variable of this type to a file.\n"
		    "The filename can be specified or an empty string.\n"
		    "See `ArrayOfMatrixWriteToFile' for more details."),
	OUTPUT(),
	INPUT(),
	GOUTPUT(ARRAYofMATRIX_),
	GINPUT(),
	KEYWORDS( "filename" ),
	TYPES(    string_t   )));

  md_data.push_back
    ( MdRecord
      ( NAME("ArrayOfVectorReadFromFile"),
	DESCRIPTION("Writes a variable of this type to a file.\n"
		    "The filename can be specified or an empty string.\n"
		    "See `ArrayOfMatrixWriteToFile' for more details."),
	OUTPUT(),
	INPUT(),
	GOUTPUT(ARRAYofVECTOR_),
	GINPUT(),
	KEYWORDS( "filename" ),
	TYPES(    string_t   )));
  

//
//=== Matrix and Vector Read Methods
//
  md_data.push_back
    ( MdRecord
      ( NAME("MatrixReadFromFile"),
	DESCRIPTION("Writes a variable of this type to a file.\n"
		    "The filename can be specified or an empty string.\n"
		    "See `ArrayOfMatrixWriteToFile' for more details."),
	OUTPUT(),
	INPUT(),
	GOUTPUT(MATRIX_),
	GINPUT(),
	KEYWORDS( "filename" ),
	TYPES(    string_t   )));

  md_data.push_back
    ( MdRecord
      ( NAME("VectorReadFromFile"),
	DESCRIPTION("Writes a variable of this type to a file.\n"
		    "The filename can be specified or an empty string.\n"
		    "See `ArrayOfMatrixWriteToFile' for more details."),
	OUTPUT(),
	INPUT(),
	GOUTPUT(VECTOR_),
	GINPUT(),
	KEYWORDS( "filename" ),
	TYPES(    string_t   )));
  


//======================================================================
//=== Absorption methods
//======================================================================


//
//=== Spectroscopic methods
//
  md_data.push_back
    ( MdRecord
      ( NAME("linesReadFromHitran"),
  	DESCRIPTION(
          "Read all the lines from a HITRAN catalogue file that\n"
	  "correspond to legal species / isotope combinations.\n"
	  "\n"
	  "The output line array is not overwritten, but the new data\n"
	  "is appended!\n" 
	  "\n"
	  "This is mainly for testing, the method probably will become\n"
	  "more complicated later on.\n"
	  "\n"
	  "filename = Name (and path) of the catalogue file.\n"
	  "fmin     = Minimum frequency for lines to read in Hz.\n"
	  "fmax     = Maximum frequency for lines to read in Hz."),
	OUTPUT(),
	INPUT(),
	GOUTPUT( ARRAYofLineRecord_ ),
	GINPUT(),
	KEYWORDS( "filename",  "fmin",    "fmax"),
	TYPES(    string_t,    Numeric_t, Numeric_t)));

  md_data.push_back
    ( MdRecord
      ( NAME("lines_per_tgCreateFromLines"),
  	DESCRIPTION(
          "Split lines up into the different tag groups.\n"
	  "The tag groups are tested in the order in which they are\n" 
          "specified in the controlfile. The line is assigned to the\n" 
	  "first tag group that fits."),
	OUTPUT(   lines_per_tg_      ),
	INPUT(    lines_, tag_groups_ ),
	GOUTPUT(),
	GINPUT(),
	KEYWORDS(),
	TYPES()));

  md_data.push_back
    ( MdRecord
      ( NAME("linesWriteToFile"),
  	DESCRIPTION(
          "Write the content of the workspace variable lines to the\n"
	  "given file in ARTS line format."),
	OUTPUT(),
	INPUT( lines_ ),
	GOUTPUT(),
	GINPUT(),
	KEYWORDS( "filename" ),
	TYPES(    string_t   )));

  md_data.push_back
    ( MdRecord
      ( NAME("lines_per_tgWriteToFile"),
  	DESCRIPTION(
          "Write the content of the workspace variable lines_per_tg to the\n"
	  "given file in ARTS line format.\n"
	  "The array dimension is handled in a similar way as by the\n"
	  "array of vector and matrix output function:\n"
	  "First an integer stating the number of tag groups.\n"
	  "Then an integer specifying the number of lines for the\n"
	  "first group. Then the other groups in similar fashion."),
	OUTPUT(),
	INPUT( lines_per_tg_ ),
	GOUTPUT(),
	GINPUT(),
	KEYWORDS( "filename" ),
	TYPES(    string_t   )));

  md_data.push_back
    ( MdRecord
      ( NAME("tag_groupsDefine"),
  	DESCRIPTION(
          "Set up the list of tag groups.\n"
	  "Specify one string for each tag group that you want to create.\n"
	  "Inside the string, separate the tags by comma (plus optional blanks).\n"
	  "Example:\n"
	  "tag = [\"O3-666-500e9-501e9, O3-686\",\"H2O\",\"O2-*-*-*\"]"),
	OUTPUT( tag_groups_ ),
	INPUT(),
	GOUTPUT(),
	GINPUT(),
	KEYWORDS( "tags" ),
	TYPES(    ARRAY_string_t   )));
  
//
//=== 1D Input Atmosphere methods
//
  md_data.push_back
    ( MdRecord
      ( NAME("raw_vmrs_1dReadFromScenario"),
  	DESCRIPTION(
	  "Read the individual VMR profile for each tag group from a standard\n"
	  "atmospheric scenario. Files must look like this example:\n"
	  "<basename>.ClO.am\n"
	  "\n"
	  "The basename can include a path, i.e., the files can be anywhere,\n"
	  "but they must be all in the same directory.\n"
	  "\n"
	  "The profile is chosen by the species name. If you have more than one\n"
	  "tag group for the same species, the same profile will be used."
	  ),
	OUTPUT(   raw_vmrs_1d_    ),
	INPUT(    tag_groups_          ),
	GOUTPUT(                       ),
	GINPUT(                        ),
	KEYWORDS( "basename"           ),
	TYPES(    string_t             )));

  md_data.push_back
    ( MdRecord
      ( NAME("Atm2dFromRaw1D"),
  	DESCRIPTION(
	  "This method is not currently useful for anything, since\n"
	  "there is no method to calculate absorption from the 2D\n"
	  "parameters.\n"
	  "\n"
	  "Interpolates temperature, altitude, and VMRs to the pressure grid\n"
	  "given by p_abs. The altitude is not used by the absorption routines,\n"
	  "But later on by the RT routines."
	  "\n"
	  "Interpolations used: FIXME: Add these.f\n"
	  "Temperature [K]: \n"
	  "Altitude    [m]: \n"
	  "VMRs        [1]: \n"
	  "\n"
	  "Uses interp_lin(...)."
	  ),
	OUTPUT(   t_abs_2d_ , z_abs_2d_   , vmrs_2d_     ),
	INPUT(    p_abs_    , raw_ptz_1d_ , raw_vmrs_1d_ ),
	GOUTPUT(                       			 ),         
	GINPUT(                        			 ),
	KEYWORDS(                      			 ),
	TYPES(                         			 )));

  md_data.push_back
    ( MdRecord
      ( NAME("AtmFromRaw1D"),
  	DESCRIPTION(
	  "Interpolates temperature, altitude, and VMRs to the pressure grid\n"
	  "given by p_abs. The altitude is not used by the absorption routines,\n"
	  "But later on by the RT routines."
	  "\n"
	  "Interpolations used: FIXME: Add these.f\n"
	  "Temperature [K]: \n"
	  "Altitude    [m]: \n"
	  "VMRs        [1]: \n"
	  "\n"
	  "Uses interp_lin(...)."
	  ),
	OUTPUT(   t_abs_    , z_abs_   , vmrs_           ),
	INPUT(    p_abs_    , raw_ptz_1d_ , raw_vmrs_1d_ ),
	GOUTPUT(                       			 ),         
	GINPUT(                        			 ),
	KEYWORDS(                      			 ),
	TYPES(                         			 )));

//
//=== 2D absorption methods
//

//
//=== 1D absorption methods
//
  md_data.push_back
    ( MdRecord
      ( NAME("AllAbsExample"),
	DESCRIPTION("Reads all important absorption related variables from the\n"
		    "given files."),
	OUTPUT(f_abs_, p_abs_, t_abs_, abs_),
	INPUT(),
	GOUTPUT(),
	GINPUT(),
	KEYWORDS(),
	TYPES()));

  


//======================================================================
//=== LOS/RTE methods
//======================================================================

  md_data.push_back
    ( MdRecord
      ( NAME("los1d"),
  	DESCRIPTION(
          "A general function to determine LOS for a 1D atmosphere.\n"
          "Refraction is selected by a flag and the refraction variables\n"
          "must be set when using this function. The ground altitude must\n"
          "also be specified."),
	OUTPUT(los_),
	INPUT( z_plat_ ,view1_, l_step_, p_abs_, z_abs_, 
               refr_, l_step_refr_, refr_index_, z_ground_ ),
	GOUTPUT(),
	GINPUT(),
	KEYWORDS(),
	TYPES()));

  md_data.push_back
    ( MdRecord
      ( NAME("los1dNoRefraction"),
  	DESCRIPTION(
          "Determines the LOS for a 1D atmosphere without refraction.\n"
          "The ground altitude must be specified."),
	OUTPUT(los_),
	INPUT( z_plat_ ,view1_, l_step_, p_abs_, z_abs_, z_ground_ ),
	GOUTPUT(),
	GINPUT(),
	KEYWORDS(),
	TYPES()));

  md_data.push_back
    ( MdRecord
      ( NAME("los1dUpward"),
  	DESCRIPTION(
          "Determines the LOS for a 1D atmosphere for upward observations,\n"
          "neglecting refraction.\n"
          "Refraction and ground altitude variables are NOT needed."),
	OUTPUT(los_),
	INPUT( z_plat_ ,view1_, l_step_, p_abs_, z_abs_ ),
	GOUTPUT(),
	GINPUT(),
	KEYWORDS(),
	TYPES()));

  md_data.push_back
    ( MdRecord
      ( NAME("source1d"),
  	DESCRIPTION(
          "Calculates the source function between the points of a 1D LOS.\n" 
          "No scattering and local thermodynamic equilibrium are assumed,\n"
          "that is, the source function equals the Planck function.\n"
          "The temparature is set to the mean value of the temperature at\n"
          "the two LOS points limiting the step. The temperature at the LOS\n"
          "points is obtained by linear interpolation"),
	OUTPUT( source_ ),
	INPUT( los_, p_abs_, t_abs_, f_abs_ ),
	GOUTPUT(),
	GINPUT(),
	KEYWORDS(),
	TYPES()));

  md_data.push_back
    ( MdRecord
      ( NAME("trans1d"),
  	DESCRIPTION(
          "Calculates the transmission between the points of a 1D LOS.\n"
          "The absorption is assumed to vary linear between the LOS points."
          "The absorption at the LOS points is obtained by linear\n"
          "interpolation."),
	OUTPUT( trans_ ),
	INPUT( los_, p_abs_, abs_ ),
	GOUTPUT(),
	GINPUT(),
	KEYWORDS(),
	TYPES()));

  md_data.push_back
    ( MdRecord
      ( NAME("y_spaceStd"),
  	DESCRIPTION(
          "Standard selection for the radiation entering the atmosphere at\n"
          "the start of the LOS. The selections are:\n"
          "  0 no radiation\n"
          "  1 cosmic background radiation (planck for 2.7 K)\n"
          "  2 solar radiation (planck for 6000 K)"),
	OUTPUT( y_space_ ),
	INPUT( f_abs_ ),
	GOUTPUT(),
	GINPUT(),
	KEYWORDS("nr"),
	TYPES(int_t)));

  md_data.push_back
    ( MdRecord
      ( NAME("y_spacePlanck"),
  	DESCRIPTION(
          "Sets the radiation entering the atmosphere at the start of the\n"
          "LOS to the Planck function for the given temperature."),
	OUTPUT( y_space_ ),
	INPUT( f_abs_ ),
	GOUTPUT(),
	GINPUT(),
	KEYWORDS("temp"),
	TYPES(Numeric_t)));

  md_data.push_back
    ( MdRecord
      ( NAME("yRte"),
  	DESCRIPTION(
          "Solves the general radiative transfer equation (RTE) along the\n"
          "LOS. With other words, both absorption and emission are\n"
          "considered."),
	OUTPUT( y_ ),
	INPUT( los_, f_abs_, y_space_, source_, trans_, e_ground_, t_ground_ ),
	GOUTPUT(),
	GINPUT(),
	KEYWORDS(),
	TYPES()));

  md_data.push_back
    ( MdRecord
      ( NAME("yRteNoGround"),
  	DESCRIPTION(
          "This function can be used instead of yRte if there is no\n"
          "intersection with the ground. The ground emission and \n"
          "temperature are NOT needed when using this function."),
	OUTPUT( y_ ),
	INPUT( los_, f_abs_, y_space_, source_, trans_ ),
	GOUTPUT(),
	GINPUT(),
	KEYWORDS(),
	TYPES()));

  md_data.push_back
    ( MdRecord
      ( NAME("yBl"),
  	DESCRIPTION(
          "Calculates the total transmission throught the atmosphere,\n"
          "using the Beer-Lambert (BL) law."),
	OUTPUT( y_ ),
	INPUT( los_, trans_, e_ground_ ),
	GOUTPUT(),
	GINPUT(),
	KEYWORDS(),
	TYPES()));

  md_data.push_back
    ( MdRecord
      ( NAME("yBlNoGround"),
  	DESCRIPTION(
          "This function can be used instead of yBl if there is no\n"
          "intersection with the ground. The ground emission is NOT needed \n"
          "when using this function."),
	OUTPUT( y_ ),
	INPUT( los_, trans_ ),
	GOUTPUT(),
	GINPUT(),
	KEYWORDS(),
	TYPES()));

  md_data.push_back
    ( MdRecord
      ( NAME("klos1d"),
  	DESCRIPTION(
          "Calculates line of sight weighting functions (LOS WFs) for 1D.\n"
          "These WFs are the derivative of the monochromatic pencil beam\n"
          "intensity with respect to the absorption at the LOS points.\n"
          "See further the ARTS user guide."),
	OUTPUT( klos_ ),
	INPUT( los_, source_, trans_, y_, f_abs_, e_ground_, t_ground_ ),
	GOUTPUT(),
	GINPUT(),
	KEYWORDS(),
	TYPES()));

}

