%
% To start the document, use
%  \chapter{...}
% For lover level, sections use
%  \section{...}
%  \subsection{...}
%
\chapter{Gridded Fields}
%-------------------------------------------------------------------------
\zlabel{sec:griddedfields}


%
% Document history, format:
%  \starthistory
%    date1 & text .... \\
%    date2 & text .... \\
%    ....
%  \stophistory
%
\starthistory
  2010-04-12 & Created and written by Oliver Lemke.\\
\stophistory




%
% Introduction
%

This section describes how gridded fields are implemented in ARTS and
how they are used. Gridded fields consist of a data object like a
Vector, Matrix, or Tensor and a grid for each dimension of its data.
For example, a \artsstyle{GriddedField1} consists of one grid and a
\artsstyle{Vector}, whereas a \artsstyle{GriddedField3} contains three grids
and a \artsstyle{Tensor3}. Grids can be either numeric, like a pressure grid,
or strings, like channel names.


\section{Implementation files}
%-------------------------------------------------------------------------
\zlabel{sec:griddedfields:files}

The \artsstyle{GriddedField1}, \artsstyle{GriddedField2},
\artsstyle{GriddedField3}, \artsstyle{GriddedField4} classes and their common
base class \artsstyle{GriddedField} described below reside in the files:

\begin{itemize}
\item \fileindex{gridded\_fields.h}
\item \fileindex{gridded\_fields.cc}
\end{itemize}

\section{Design}
%-------------------------------------------------------------------------
\zlabel{sec:griddedfields:design}



\subsection{The abstract base class \artsstyle{GriddedField}}
%-------------------------------------------------------------------------

The abstract base class \artsstyle{GriddedField} implements the properties
all gridded fields have in common. These are mostly the methods to create,
set, and access the grids. A \artsstyle{GriddedField} is never instantiated
directly.


\subsection{Multiple inheritance}
%-------------------------------------------------------------------------

The \artsstyle{GriddedFieldX} classes use multiple inheritance to combine a
data object with the grids, see Figure \zref{fig:griddedfields:uml}.

\begin{figure}[ht!]
\begin{center}
\includegraphics{Figs/development/griddedfields_inheritance}
\caption{UML diagram of gridded field inheritance.}
\zlabel{fig:griddedfields:uml}
\end{center}
\end{figure}


\section{Constructing Gridded Fields}
%-------------------------------------------------------------------------
\zlabel{sec:griddedfields:construct}


\subsection{Creation}
%-------------------------------------------------------------------------
\zlabel{sec:griddedfields:create}

Each \artsstyle{GriddedFieldX} offers two constructors. One default
constructor that creates an unnamed gridded field and a second constructor
that takes a string with the name of the gridded field as an argument.

\begin{verbatim}
GriddedField1 gfone("I'm a GriddedField1");
GriddedField2 gftwo;

gftwo.set_name ("I'm a GriddedField2");
\end{verbatim}


\subsection{Initializing the grids}
%-------------------------------------------------------------------------
\zlabel{sec:griddedfields:initgrids}

Once a gridded field has been created, we can start setting up the
grids. There are two different types of grids, a numeric grid and a
string grid. In the following example we set up two gridded fields: A
\artsstyle{GriddedField1} with a numeric grid and a \artsstyle{GriddedField2}
with a numeric grid for the rows and a string grid for the columns. Each grid
can be assigned a name to describe its contents or unit.

\begin{verbatim}
Vector gfonegrid(1,5,1);        // gfonegrid = [1,2,3,4,5]
gfone.set_grid(0, gfonegrid);   // Set grid for the vector elements.

Vector gftwogrid0(1,5,1);       // gftwogrid0 = [1,2,3,4,5]
MakeArray<String> gftwogrid1("Chan1", "Chan2", "Chan3");

gftwo.set_grid(0, gftwogrid0);  // Set grid for the matrix rows.
gftwo.set_grid(1, gftwogrid1);  // Set grid for the matrix columns.

gfone.set_grid_name (0, "Pressure");

gftwo.set_grid_name (0, "Pressure");
gftwo.set_grid_name (1, "Channel");
\end{verbatim}

\subsection{Initializing the data}
%-------------------------------------------------------------------------
\zlabel{sec:griddedfields:initdata}

Because gridded fields do not only inherit from \artsstyle{GriddedField} but
also from the class of the data they contain, it is possible to treat them in
exactly the same way. See Figure \zref{fig:griddedfields:objects}.

\begin{figure}[ht!]
\begin{center}
\includegraphics{Figs/development/griddedfields_objects}
\caption{Visualization of gridded field objects.}
\zlabel{fig:griddedfields:objects}
\end{center}
\end{figure}

Let us take the \artsstyle{gfone} variable from the previous examples.
\artsstyle{gfone} is a \artsstyle{GriddedField1} which means it has
\artsstyle{GriddedField} and \artsstyle{Vector} as superclasses. Polymorphism
allows us to use a \artsstyle{GriddedField1} in every place where it is valid
to use a \artsstyle{Vector}. The only requirement is casting the gridded field
to the corresponding data type.

\begin{verbatim}
Vector avector(1,4,0.5);    // avector = [1,1.5,2,2.5]

(Vector&)gfone = avector;

Matrix amatrix(5,3,4.);     // amatrix = [[4,4,4],[4,4,4],...]

(Matrix&)gftwo = amatrix;
\end{verbatim}

\subsection{Consistency check}
%-------------------------------------------------------------------------
\zlabel{sec:griddedfields:consistency}

After initializing or changing either the grids or the data, it can happen
that the size of the grids does not match the size of the data anymore. Each
gridded field provides a convenience function which can be called to perform a
consistency check.

\begin{verbatim}
if (!gfone.checksize())
  cout << gfone.get_name()
       << ": Sizes of grid and data don't match" << endl;

// This should fail!
if (!gftwo.checksize())
  cout << gftwo.get_name()
       << ": Sizes of grids and data don't match" << endl;
\end{verbatim}

The complete source code of the examples from this chapter can be found in
\artsstyle{src/test\_gridded\_fields.cc}.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "arts_developer"
%%% End:

