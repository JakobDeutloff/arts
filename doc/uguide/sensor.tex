\levela{Sensor modeling}
 \label{sec:sensor}


%
% Document history, format:
%  \starthistory
%    date1 & text .... \\
%    date2 & text .... \\
%    ....
%  \stophistory
%
\starthistory
  031205 & Revised and extended by Mattias Ekstr\"om. \\
  000826 & Written for ARTS-1 by Patrick Eriksson.\\
\stophistory


%
% Symbol table, format:
%  \startsymbols
%    ... & \verb|...| & text ... \\
%    ... & \verb|...| & text ... \\
%    ....
%  \stopsymbols
%
%
\startsymbols
$w_\mathrm{a}$  & \artsstyle{antenna\_diagram} & The antenna pattern \\
  & \artsstyle{antenna\_dim} & The dimensionality of the antenna pattern \\
  & \artsstyle{f\_backend} & The frequency grid of the backend channels \\
  & \artsstyle{f\_mixer} & Output frequency grid from the mixer \\
  & \artsstyle{lo} & Local oscillator frequency \\
\MtrStl{P} & \artsstyle{sensor\_pol} & The sensor polarisation response \\
\SnsMtr & \artsstyle{sensor\_response} & The total sensor response matrix \\
  & \artsstyle{sensor\_response\_f} & The sensor frequency grid \\
  & \artsstyle{sensor\_response\_za} & The sensor zenith angle grid \\
  & \artsstyle{sensor\_response\_aa} & The sensor azimuth angle grid \\
  & \artsstyle{sensor\_rot} & The rotation of the sensor between measurement blocks \\
 \label{symtable:sensor}     
\stopsymbols



%
% Introduction
%

A sensor model is needed because a practical instrument gives
consistently spectra deviating from the hypothetical monochromatic
pencil beam spectra provided by the atmospheric part of the forward
model (that is $\mathbf{y} \neq \mathbf{i}$ always). For a radio (heterodyne)
instrument, the most influential sensor parts are the antenna, the
mixer, the sideband filter and the spectrometer. Limb sounding
observations are also affected by Doppler shifts, but this effect is
not considered here, it is assumed to be treated separately.

In the follow text we will use the terms sensor to denote the total
sensor configuration, i.e. the the whole object that will be
represented by the WSV \artsstyle{sensor\_response}. To denote 
individual parts of the sensor, such as the antenna or the mixer, we
use the terms sensor parts or instrument, especially when taking
of characteristics.
%Conversion of radiances to brightness temperatures is also treated
%here.

%--------------------------
\levelb{Internal functions}
Description of the concept with forward matrices. Show pictures?

\levelc{Weighting}
Decribe how the weighting matrices work and are derived.

\levelc{Summation}
Decribe how the summation matrices work and are derived.

%----------------------------------
\levelb{Instrument characteristics}
\FIXME{rewrite}

In an effort to keep a consitency between the different sensor parts, 
some general concepts has been determined for the variables and 
methods connected to sensor modelling.
Examples of this are the way the instrument characteristics are 
stored and the of course the way the sensor response is modelled 
as matrix, as decribed above (REF?).

To be able of computing the response from a certain sensor part, we 
need the instrument characteristics. This information thus have to 
be stored in such a way that we can incorporate it in our forward 
model. ARTS uses XML-files to store and retrieve variables from 
files. Thus it is easiest to store the characteristics in form of 
XML-files, but there exist also methods for computing simple gaussian
characteristics. See section~\ref{sec:sensor:WSM} for more details.

Even though the different sensor parts are very different in their
representation of their characteristics, we have tried to apply the 
same concept when applying them to the forward model. This is where
the concept of \textit{single or complete} is used. The words 
\textit{single} and \textit{complete} describes the way the given 
characteristics are applied. This might better be understood with an
example, e.g. the antenna, if only one set of antenna characteristics
are given the same set will for instance be used for all polarisations.
If on the other hand a individual set of antenna characteristics are 
given for each polarisation, then that individual set will be used
for each individual polarisation.
What this imply is that you can't give instrument characteristics
for only half of the cases, you have to give one set, \textit{single},
or one set for each case, \textit{complete}.

How this is implemented for each sensor part will be described in the 
sections concerning the different sensor parts.

%--------------------------------------
\levelb{Sensor response initialisation}
Even if the monochromatic pencil beam spectrum is studied without any sensor influence, the sensor variables, especially \SnsMtr\ has to be set. The reason is that the WSM \artsstyle{RteCalc} always applies a \SnsMtr\ to the spectrum or spectra. On the other hand if a response from a sensor system should be applied to the spectral values the sensor variables has to be initialised properly. For these tasks there exist two WSMs, \artsstyle{sensorOff} and \artsstyle{sensor\_responseInit}. At least one of these has to be included in the control file.

\levelc{No sensor}
If the calculated monochromatic pencil beams is to be studied as is, i.e.~there is no sensor system present in the simulation, only one WSM is needed \artsstyle{sensor\_off}. It sets all the necessary sensor variables so that the monochromatic pencil beams are unchanged. This means setting \SnsMtr\ to be an identity matrix. Other variables that are set by \artsstyle{sensor\_off} are \artsstyle{sensor\_pol}, \artsstyle{sensor\_rot}, \artsstyle{antenna\_dim}, \artsstyle{mblock\_za\_grid}, \artsstyle{mblock\_aa\_grid} and all the \artsstyle{sensor\_response\_}\ldots variables.
The syntax to disable the sensor in the simulation is simply;
\begin{verbatim}
sensorOff{}
\end{verbatim}

\levelc{Initialisation}
When there is a sensor system present in the simulation the sensor response variables has to be set up in a correct way. The WSM \artsstyle{sensor\_responseInit} takes care of this. It sets the \SnsMtr\ to be an identity matrix with size so that is it applicable to the monochromatic pencil beam column vector. It also initialises
the \artsstyle{sensor\_response\_}\ldots variables, \artsstyle{sensor\_response\_f}, \artsstyle{sensor\_response\_za}, \artsstyle{sensor\_response\_aa} and \artsstyle{sensor\_response\_pol}. These are updated by all succeeding sensor response WSMs, and therefor gives the accurate output grids and values for the frequency and zenith- and azimuth angle grids and number of polarisations. The output grids for the initial sensor response are \artsstyle{f\_grid}, \artsstyle{mblock\_za\_grid} and
\artsstyle{mblock\_aa\_grid} and the number of polarisation equals \artsstyle{stokes\_dim}. These WSV has to be set prior to calling \artsstyle{sensor\_responseInit} together with the position and line-of-sight of the sensor and the atmosphere dimension.

An example syntax for calling the initialisation method looks like the following. Note that the filesnames used are just examples. First the atmosphere dimension is set, here to 1D, and the sensor position and line-of-sight is defined.
\begin{verbatim}
AtmosphereSet1D {}
ReadXML( sensor_pos ) { "sensor_pos.xml" }
ReadXML( sensor_los ) { "sensor_los.xml" }
\end{verbatim}
Then the required grid are specified. Here they are read from XML-files. The WSM \artsstyle{AntennaSet1D} sets both the antenna dimension and the azimuth angle grid.
\begin{verbatim}
ReadXML( f_grid ) { "f_mono.xml" }
ReadXML( mblock_za_grid ) { "za_pencil.xml" }
AntennaSet1D {} 
\end{verbatim}
Finally, the sensor response is computed
\begin{verbatim}
sensor_responseInit {}
\end{verbatim}

%-----------------------------
\levelb{Polarisation response}
Taking polarisation into account, and assuming no losses, the measured intensity for a certain direction and frequency , $I_p$, is
\begin{equation}
\label{eq:sensor:pol:response}
  I_\mathrm{p} = \frac{1}{2} \mathbf{p} \mathbf{s}
\end{equation}
where $\mathbf{s}$ is the Stokes components of the incoming radiation and $\mathbf{p}$ is a row vector of the same length as $\mathbf{s}$ describing the sensor polarisation response. 
For an instrument measuring a single polarisation, the first element of $\mathbf{p}$ shall be one and the three last elements shall fulfil $\sum_{i=2}^4 p_i^2 = 1$, where
$p_i$ is the $i$:th element of $\mathbf{p}$. For example, if vertical polarisation is measured, then $\mathbf{p}=[1\ 1\ 0\ 0]$ and for linear $\pm45^\circ$ polarisation $\mathbf{p}=[1\ 0\ \mp\!\!1\ 0]$.  

To study different polarisations in ARTS, these has to be defined by the polarisation matrix \MtrStl{P} (\artsstyle{sensor\_pol}). This is a matrix where each row is a row vector $\mathbf{p}$ corresponding to the polarisation to study and the columns matches the Stokes components of the simulation. The number of columns must therefor equal the Stokes dimension of the simulation, see section \ref{sec:polarization} for more information and especially section \ref{sec:polarization:measuring} for examples of some standard polarisations. An example matrix for studying horisontally and right-handed circular polarisation would look like
\begin{displaymath}
  \MtrStl{P} = \left[ \begin{array}{c c c c}
  1 & -1 & 0 & 0 \\ 1 & 0 & 0 & 1 \\ 
  \end{array} \right].
\end{displaymath}
When initialised \MtrStl{P} is set to be the identity matrix, so to study all Stokes
components nothing more has to be done. As an example the \artsstyle{sensor\_pol} matrix can be read from XML-file;
\begin{verbatim}
ReadXML( sensor_pol ) { "sensor_pol.xml" }
\end{verbatim}
now it is possible to call the computing function
\begin{verbatim}
sensor_responsePolarisation {}
\end{verbatim}
and now \SnsMtr\ is updated to include the polarisation response.

%------------------------
\levelb{Antenna response}
\label{sec:sensor:antenna}
The influence of the antenna can be expressed as a weighting between the antenna response, $w_\mathrm{a}$, as a function of viewing direction and the MPBR field, $I$:
\begin{equation}
  I_\mathrm{a} = \int_{4\pi}\!\!\!\!I(\Omega+\Omega_0) 
  w_\mathrm{a}(\Omega) \; \mathrm{d}\Omega
  \quad \textrm{with} \quad 
  \int_{4\pi}\!\!\!\!w_\mathrm{a}(\Omega)\;\mathrm{d}\Omega = 1.
\end{equation} 
where $I_\mathrm{a}$ is the apparent radiation intensity after the antenna,
$\Omega$ is solid angle and $\Omega_0$ is some reference point for the
antenna pattern, normally the point of highest response.
In ARTS the pencil beams are calculated for each measurement block at the angles
given by \artsstyle{mblock\_za\_grid} and \artsstyle{mblock\_aa\_grid} added to the current line-of-sight, \artsstyle{sensor\_los}, as described in \ref{sec:fm_defs:sensorchar}. The weights  $w_\mathrm{a}$ are described by the WSV \artsstyle{antenna\_diagram} that describes the angular dependent antenna pattern. 
ARTS is prepared to handle a full 3D environment with a 2D antenna, but so far only methods for 1D antennas have been developped. 

\levelc{Antenna diagram}
\FIXME{Change of concept?}

The antenna diagram $w_\mathrm{a}$ in ARTS is represented by a structure \artsstyle{antenna\_diagram} that consists of an array of arrays of matrices. The reason to use such a complicated structure is to preserve as much variability as possible when describing the antenna pattern. With this structure it is possible to define the antenna response for different viewing angles, polarisations and frequencies. 
Since there only exists a method 1D antennae, $w_\mathrm{a}$ is so far only defined for 1D antenna patterns. The structure consists of matrices that describe the weights for different angles. The first column in matrices describes the angular grid and the following columns the weights for different frequencies, see figure~\ref{fig:sensor:ant_diag}. Each polarisation is then represented by a separate matrix and each viewing angle by an array of matrices. By using arrays of matrices instead of tensors it is also possible to use different settings for the different polarisations/viewing directions. For each of these sets it is possible to define only one column, matrix or array of matrices, or a full set of columns, matrices or arrays of matrices. E.g.~for the most simple case where the antenna has the same pattern for all directions and frequencies $w_\mathrm{a}$ consists of a single array of matrix with a single two column matrix.
\begin{figure}[!ht]
\label{fig:sensor:ant_diag}
\begin{center}
  \includegraphics*{Figs/sensor/ant_diag}
  \caption{Visualisation of the antenna pattern WSV \artsstyle{antenna\_diagram} for   
  two viewing directions $\varphi_1$ and $\varphi_2$, $\Delta\varphi$ is the relative   
  angular grid, $f_i$ the $i$:th frequency and $p_j$ the $j$:th polarisation.}
\end{center}
\end{figure}

\levelc{1D antenna}
Here it will be assumed that the variation of $I$ in one angular dimension can be neglected, and that the weighting can be described by an one dimensional integral:
\begin{eqnarray}
\label{eq:sensor:antenna:1D}
  I_\mathrm{a} &=& \int_{-\pi}^\pi\!\!\!\!I(\theta+\theta_0) 
  w_\mathrm{a}^\theta(\theta)\;\mathrm{d}\theta,\\
  w_\mathrm{a}^\theta(\theta) &=& \int_0^{2\pi}\!\!\!\!
  w_\mathrm{a}(\theta,\phi)\cos(\theta)\,\mathrm{d}\phi,
\end{eqnarray}
where $\theta_0$ is the reference angle of the antenna.


\begin{verbatim}
AntennaSet1D {}

ReadXML( matrix_1 ) { "ant_diag.xml" }
ArrayOfMatrixSet( arrayofmatrix_1, matrix_1 ) { element=0 }
antenna_diagramAppendArray( arrayofmatrix_1 ) {}

ReadXML( vector_1 ) { "antenna_za.xml" }

sensor_responseAntenna1D( vector_1 ) {}
\end{verbatim}

%------------------------------------------
\levelb{Mixer and sideband filter response}
\begin{verbatim}
ReadXML( lo ) {
  "../xml/lo.xml"
}

ReadXML( matrix_1 ) {
  "../xml/sbfilter.xml"
}

sensor_responseMixer( matrix_1 ) {}
\end{verbatim}

%------------------------
\levelb{Backend response}
\begin{verbatim}
ReadXML( matrix_1 ) {
  "../xml/ac_channel.xml"
}

ArrayOfMatrixSet( arrayofmatrix_1, matrix_1 ) {
  element = 0
}

sensor_responseBackend( arrayofmatrix_1 ) {}
\end{verbatim}


%---------------------------
\levelb{Auxiliary functions}
\artsstyle{ConvertIFToRF} \ldots

\levelb{Control file example}

\hrule


%-------------------------
\levelb{Workspace methods}
\label{sec:sensor:WSM}

%------------------------------------------------------
\levelb{Controlfile implementation(flow, step-by-step)}



%\levelb{Implementation strategy}
% \label{sec:sensor:strategy}

%\levelc{The sensor transfer matrix}
% \label{sec:sensor:strategy:h}
 
% The modeling of a sensor part is either a summation of different
% frequency components (mixer), or a weighting of the spectra as a
% function of frequency (spectrometer) or viewing direction (antenna)
% with the instrument response of concern. In all cases it is
% possible to describe the sensor influence by an analytical
% expression. See for example \citet{eriksson:97a} for more details.
% These analytical expressions can be implemented and solved for each
% run of the sensor model, but this would be relatively computationally
% demanding for cases when the settings are kept constant, as the
% calculations are duplicated in an unnecessary manner, and we want to
% find a better implementation strategy.
 
% Summation and weighting of the spectral components are both linear
% operations, and thus it is possible to model the effect of the
% different sensor parts as subsequent matrix multiplications of the
% monochromatic pencil beam spectrum, as suggested in \citet{eriksson:00a}:
% \begin{eqnarray}
%   \y = \Hm_n\dots\Hm_2\Hm_1\iv + \merr
% \end{eqnarray}
% where $n$ is the number of sensor parts to consider, and this results
% in that the sensor model can be expressed as a single matrix
% multiplication (Eq. \ref{eq:formalism:H})
% \begin{eqnarray}
%   \y = \Hm\iv + \merr                     \nonumber
% \end{eqnarray}
% Applying Equation \ref{eq:formalism:H} for the sensor model will
% clearly give very rapid calculations, and we must find ways to
% calculate $\Hm$.


%\levelc{Normalization of \Hm}
% \label{sec:sensor:strategy:norm}
 
% It is important that the transfer matrix for
% each sensor part is normalized in such way that a unit response is
% obtained. A unit response signifies here that a constant intensity
% (as a function of frequency or zenith angle) is preserved, that is
% \begin{equation}
%   \mat{u}_2 = \Hm\mat{u}_1
% \end{equation}
% where $\mat{u}_1$ and $\mat{u}_2$ are vectors of appropriate length
% where each element is $1$. This criterion equals that the sum of 
% the elements of each row of \Hm\ is 1.


%\levelb{Integration as vector multiplication} 
% \label{sec:sensor:integr}
  
% The effect of both the antenna and the spectrometer can be expressed
% as an integral \citep[e.g.][Eq. 86 and 94]{eriksson:97a}, and the
% question is how to transform these integrals into matrix operations.
  
% The problem at hand is that the antenna and spectrometer responses
% and the zenith angle and frequency grids are known, while the spectral
% values are unknown. This problem corresponds to determine a (row)
% vector $\mat{h}$ that multiplied with an unknown (column) vector,
% $\mat{g}$, approximates the integral of the product between the
% functions $g$ and $f$:
% \begin{equation} 
%   \mat{hg} = \int{f(x)g(x) \dd x}
%   \label{eq:sensor:integral_problem}
% \end{equation}
% where $\mat{g}$ contains values of $g$ at some discrete points. The
% functions $f$ is here the response for some sensor part, and $g$
% holds the spectral values. The shape of $f$ and $g$ between the grid
% points must be known to solve this problem.


%\levelc{Piecewise linear functions} 
% \label{sec:sensor:integr:lins}
 
% In this section the problem of
% Equation~\ref{eq:sensor:integral_problem} is solved analytically when
% both functions are piecewise linear. The practical solution used
% Qpack is discussed in next section.
  
% Following Figure \ref{fig:sensor:vecintegr}, the function $g$ can between
% the points $x_1$ and $x_4$ be expressed as a sum of the two unknown
% values $g_1$ and $g_2$:
% \begin{equation}
%   g(x) = g_1 + (g_2-g_1)\frac{x-x_1}{x_4-x_1} =
%           g_1 \frac{x_4-x}{x_4-x_1} + g_2\frac{x-x_1}{x_4-x_1}
% \end{equation}
% which can be rewritten as
% \begin{equation}
%   g(x) = g_1(a+bx)+g_2(c-bx), \qquad x_1 \leq x \leq x_4
%   \label{eq:sensor:glin}
% \end{equation}
% where
% \begin{eqnarray}
%    a=\frac{x_4}{x_4-x_1}, \qquad b=\frac{-1}{x_4-x_1}, \qquad 
%    c=\frac{-x_1}{x_4-x_1}   \nonumber
% \end{eqnarray} 
% A shorter expression can be obtained for the function $f$ as the
% values $f_1$ and $f_2$ are known:
% \begin{equation}
%   f(x) = (d+ex), \qquad x_2 \leq x \leq x_3
% \end{equation}
% where 
% \begin{eqnarray}
%    d=f_1-x_2\frac{f_2-f1}{x_3-x_2} \qquad e=\frac{f_2-f_1}{x_3-x_2} \nonumber
% \end{eqnarray}
% \begin{figure}[tb]
%    \begin{center}
%      \includegraphics*{Figs/vecintegr}
%      \caption{The quantities used in Section \ref{sec:sensor:integr}.}  
%      \label{fig:sensor:vecintegr} 
%    \end{center} 
% \end{figure}
% The integral in Equation \ref{eq:sensor:integral_problem} can now for
% ranges between $x_2$ and $x_3$ be calculated analytically in a
% straightforward manner:
% \begin{eqnarray}
%    \int_{x_a}^{x_b}{f(x)g(x) \dd x} =
%    \int_{x_a}^{x_b}{\big(d+ex\big)\big(g_1(a+bx)+g_2(c-bx)\big) \dd x}  
%    =\dots= \nonumber\\
%    \bigg[ g_1x\Big(ad+\frac{x}{2}(bd+ae)+\frac{x^2}{3}be\Big) + 
%           g_2x\Big(cd+\frac{x}{2}(ce-bd)-\frac{x^2}{3}be \Big)
%           \bigg]_{x_a}^{x_b}
%    \label{eq:sensor:integr_weights}
% \end{eqnarray}
% For the practical calculations, the integral is solved from one grid
% point to next, of either $\mat{f}$ or $\mat{g}$. The functions are 
% assumed to be zero outside their defined ranges (for example, $f=0$ 
% for $x<x_2$).
% For the case
% shown in Figure \ref{fig:sensor:vecintegr}, the integration order would be
% $(x_a,x_b)=(x_2,x_3)$, $(x_a,x_b)=(x_3,x_4)$, $(x_a,x_b)=(x_4,x_5)$
% \ldots\
  
% Using Equation \ref{eq:sensor:integr_weights}, we can now determine how to
% calculate $\mat{h}$. For each integration step, $\mat{h}_i$ and
% $\mat{h_{i+1}}$ are increased as
% \begin{eqnarray}
%    \mat{h}_i \!\! &=& \!\! \mat{h}_i +    
%              x_b\Big(ad+\frac{x_b}{2}(bd+ae)+\frac{x_b^2}{3}be\Big) - 
%              x_a\Big(ad+\frac{x_a}{2}(bd+ae)+\frac{x_a^2}{3}be\Big) 
%    \nonumber \\
%    \mat{h}_{i+1} \!\! &=& \!\! \mat{h}_{i+1} +
%              x_b\Big(cd+\frac{x_b}{2}(ce-bd)-\frac{x_b^2}{3}be\Big) - 
%              x_a\Big(cd+\frac{x_a}{2}(ce-bd)-\frac{x_a^2}{3}be\Big) 
%    \nonumber
% \end{eqnarray}
% where $i$ is the index for which $\mat{x}^i \leq x_a$ and $x_b \leq
% \mat{x}^{i+1}$. The vector $\mat{h}$ is initialized with
% zeros before the calculation starts.


%\levelc{Practical solution} 
% \label{sec:sensor:integr:practical}
 
% The functions $f$ and $g$ can in Qpack be treated to be piecewice
% linear or cubic functions. The polynomial order of the two functions
% is set individually. When a function is assumed to be piecewise
% cubic, two points on each side of the range of interest (that is, in
% total 4 points) are used to determine the polynomial. For the end
% ranges, a quadratic polynomial is used as there exists only a single
% point on one of the sides. 
 
% Accordingly, Equation~\ref{eq:sensor:integral_problem} must be
% handled in Qpack for combinations of piecewise linear, quadratic and
% cubic functions. Instead of repeating the calculations in Section
% \ref{sec:sensor:integr:lins} for all possible polynomial
% combinations, a more general solution was implemented. The polynomial
% coefficents for $f$ are simply obtained by doing a polynomial fit to
% the considered points (by the Matlab function \verb|polyfit|). The
% polynomial basis for $g$ ($a$, $b$ and $c$ in Equation
% \ref{eq:sensor:glin}) is obtained by Lagrange's formula (Equation
% \ref{eq:wfuns:lagrange}), which expresses the polynomial that passes
% a fixed set of points. The Lagrange's formula can be written as:
% \begin{eqnarray}
%  g(x) &=& (a_{11}+a_{12}x+\dots+a_{1N}x^N)*g_1 + \nonumber \\
%       & & (a_{21}+a_{22}x+\dots+a_{2N}x^N)*g_2 + \nonumber \\
%       & & \dots \nonumber \\
%       & & (a_{N1}+a_{N2}x+\dots+a_{NN}x^N)*g_N 
%  \label{eq:sensor:pbasis}
% \end{eqnarray}
% With the obtained coefficients for $f$ and $g$, Equation
% \ref{eq:sensor:integr_weights} can easily be solved analytically in a
% general manner. The polynomial pasis is determined by the AMI
% function \verb|pbasis|, the both set of coefficients are
% multiplicated in the function \verb|pbasis_x_pol| and the integral is
% solved by the function \verb|pbasis_integrate|.


%\levelb{Summation as vector multiplication}
% \label{sec:sensor:mixer}
  
% The influence of the mixer and sideband filter of the sensor
% correspond to a summation of pairs of frequency components. The two
% frequencies of the pair are related as
% \begin{equation}
%    \f' = 2\f_{LO}-\f
% \end{equation}
% where $\f_{LO}$ is the frequence of the local oscillator signal, and
% $\f'$ is denoted as the image frequency.

% \begin{figure}[tb]
%  \begin{center}
%    \includegraphics*[width=0.8\hsize]{Figs/sideband}
%    \caption{Schematic description of image frequency and sideband filtering.}
%   \label{fig:sensor:sideband} 
%  \end{center} 
% \end{figure}
 
% The intensity correspondence after the mixer and the sideband filter
% can be written as
% \begin{equation}
%   I_{IF}(\f) = \frac{f_s(\f)I(\f)+f_s(\f')I(\f')}{f_s(\f)+f_s(\f')}
%  \label{eq:sensor:sband}
% \end{equation}
% where $I(\f)$ is the intensity for frequency $\f$ and $f_s$ the response
% of the sideband filter as a function of frequency.

% The frequency grid after the mixer consists of the frequencies inside
% the primary band of the grid before the mixer. To include frequencies
% from the image band (mirrored to the primary band) would need an 
% interpolation in the primary band that could cause unexpected effects.  


%\levelc{Piecewise linear functions} 
% \label{sec:sensor:mixer:lins}

% If the intensity is assumed to vary linearly between the points of the
% frequency grid, Equation \ref{eq:sensor:sband} can be written as
% \begin{eqnarray}
%   I_{IF}(\f^i) &=& \frac{1}{f_s(\f_i)+f_s(\f_i')} \bigg[ f_s(\f_i)I(\f_i)+ \nonumber \\ 
%      & & + \frac{f_s(\f_i')}{\f_{j+1}-\f_j} \Big( I(\f_j)(\f_{j+1}-\f_i')
%           + I(\f_{j+1})(\f_i'-\f_j) \Big)  \bigg]
%  \label{eq:sensor:mixer}
% \end{eqnarray}
% where $f_s$ for the different frequencies is obtained by linear
% interpolation, and $\f_j$ and $\f_{j+1}$ are the two
% points of the frequency grid surrounding the image frequency,
% $\f_i'$. The row of the $\Hm$ matrix corresponding to $\f^i$ is then
% \begin{eqnarray}
%    \label{eq:sensor:mixer:hi}
%    \mat{h}^i &=& \frac{f_s(\f_i)}{f_s(\f_i)+f_s(\f_i')}  \\
%    \mat{h}^j &=& \frac{f_s(\f_i')}{f_s(\f_i)+f_s(\f_i')}
%                  \frac{\f_{j+1}-\f_i'}{\f_{j+1}-\f_j}     \nonumber \\
%    \mat{h}^{j+1} &=& \frac{f_s(\f_i')}{f_s(\f_i)+f_s(\f_i')}
%                  \frac{\f_i'-\f_j}{\f_{j+1}-\f_j}     \nonumber
% \end{eqnarray}
% where $\mat{h}^i$ is the value of $\mat{h}$ for frequency $\f_i$ etc.
% Remaining values of $\Hm$ are zero.

% For the special case when the image frequency matches perfectly a frequency
% grid point, the equations above can be simplified to give
% \begin{eqnarray}
%    \mat{h}^i &=& \frac{f_s(\f_i)}{f_s(\f_i)+f_s(\f_i')}    \nonumber \\
%    \mat{h}^j &=& \frac{f_s(\f_i')}{f_s(\f_i)+f_s(\f_i')}    \nonumber
% \end{eqnarray}


%\levelc{Practical solution} 
% \label{sec:sensor:mixer:practical}
 
% The responses of the sideband filter is determined by linear or cubic
% interpolation, dependent on the selected order.
% As the frequency in the primary band always equals one of the points
% of the monochromatic frequency grid, Equation
% \ref{eq:sensor:mixer:hi} can be used throughout. The weights for the
% image band are found by evaluating the polynomial basis from Equation
% \ref{eq:sensor:pbasis} at $\f_i'$ and multiplicate with 
% $f_s(\f_i') / (f_s(\f_i)+f_s(\f_i'))$. These calculations are 
% performed in the AMI function \verb|h_matrix|.

 
%\levelb{Brightness temperature} 
% \label{sec:sensor:tb}

% Some kind of calibration process, either in absolute or relative units,
% is always needed. For mm and sub-mm receivers, the calibration normally
% presents the measured intensity in some temperature scale, and conversion
% to brightness and Rayleigh-Jeans temperatures is also treated in this section.


%\levelc{Conversion to Planck brightness temperature} 
% \label{sec:sensor:tb_planck}

% The brightness temperature is defined as the temperature a blackbody 
% shall have to give the same intensity magnitude as observed. The 
% brightness temperature is thus calculated as
% \begin{equation}
%   T_b = \frac{h\f}{k_B} \frac{1}{\ln{ \left( \frac{2h\f^3}{c^2\mpbi}+1 \right)}}
%   \label{eq:sensor:cal:tb}
% \end{equation}
% where \mpbi\ is the radiative intensity.
 
% It should be noted that the conversion from intensity to brightness
% temperature is non-linear. This non-linearity has (at least) two important
% consequences:
% \begin{itemize}
%  \item The conversion from intensity to brightness temperature cannot be
%        included in \Hm.
%  \item \bf{Brightness temperature cannot be used for retrievals.}
% \end{itemize}
% Accordingly, the main reason to convert a spectrum to brightness
% temperatures is to display the spectrum in an unit that gives a more
% intuitive understanding of the emission magnitude.


%\levelc{Conversion to Rayleigh-Jean temperature} 
% \label{sec:sensor:tb:rj}

% For lower frequencies where $h\f \ll k_BT$ the Planck function can
% be approximated by the Rayleigh-Jean (RJ) formula:
% \begin{equation}
%   B \approx \frac{2\f^2k_BT}{c^2}
% \end{equation}
% This relationship holds rather well in the microwave region. For example,
% for $T=50$~K, $h\f = k_BT$ at 1.04~THz. The RJ approximation of the Planck
% function gives a natural definition on a ``brightness temperature'' with
% that has a linear relationship to the intensity:
% \begin{equation}
%   T_{rj} = \frac{c^2}{2\f^2k_B} \mpbi
%   \label{eq:sensor:cal:rj}
% \end{equation}
% This intensity unit is often referred to as the brightness temperature but
% to avoid confusion it is here denoted as the RJ temperature.
 
% As the intensity from intensity to RJ temperature is linear, this
% conversion can be included in \Hm\ and weighting functions can be
% converted using \ref{eq:sensor:cal:rj}, that is, retrievals are
% possible using RJ temperatures.
% On the other hand, the RJ temperature shall not be mistaken for the
% ``physical'' brightness temperature $(T_b)$ as the deviation between
% $T_b$ and $T_{rj}$ is not negligible \citep{eriksson:97a}.


%\levelb{Control file examples}
% \label{sec:sensor:cfe}

% The following sequence of ARTS functions can be used to store the
% spectra in both brightness temperature units:

% {\footnotesize
% \begin{verbatim}
%VectorCopy( y0, y ) {
%}
%yTRJ{
%}
%VectorWriteAscii( y ) {
%   "ytb_rj.aa"
%}
%VectorCopy( y, y0 ) {
%}
%yTB{
%}
%VectorWriteAscii( y ) {
%   "ytb_planck.aa"
%}
% \end{verbatim}
% }
% \noindent
% A weighting function matrix is converted to Rayleigh-Jean temperature
% as:

% {\footnotesize
% \begin{verbatim}
%MatrixTRJ( kx, kx ) {
%}

% \end{verbatim}
% }
 


%%% Local Variables: 
%%% mode: latex 
%%% TeX-master: "uguide" 
%%% End:

