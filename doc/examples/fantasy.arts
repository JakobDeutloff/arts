
# How should the Controlfile of the future look like?
# This is one that computes the gas absorption lookup table
# gas_abs_table. 


Main {

   # Rename tgs to gas_tgs, to make the distinction from
   # particles. Furthermore, we introduce a new tag atribute "-nl", which
   # can be used instead of the istotope and means that no explicit
   # lines (from line catalouges) should be considered for this tag.

   gas_tgsDefine{
      ["H2O","O2","O3-666","O3","N2O","N2-nl"]
   }

   # FIXME: Somehow load the atmosphere and the concentration
   # profiles. Should there be separate loading methods for the
   # different dimensions?

   # Create the frequency grid `f_mono':
   VectorNLinSpace(f_mono){
           start = 50e9
           stop  = 150e9
           n     = 100    
   }

   # The next task is to somehow assign the right spectral lines to
   # those gas_components for which explicit line-by-line calculations
   # should be done. 
	
   # Set all line lists to empty
   lines_per_tgInit{}

   linesReadFromArts {
      filename = "thomas.al"
      fmin     = 1e9
      fmax     = 200e9
   }

   # This will put the matching lines in the apropriate line list.
   lines_per_tgPut{
      tgs = [ "H2O"    ]
   }

   linesReadFromHitran {
      filename = "/pool/lookup2/arts-data/spectroscopy/hitran96/hitran96_lowfreq.par"
      fmin     = 1e9
      fmax     = 200e9
   }

   # This will consider all tgs for which the line list is still empty.
   lines_per_tgPut{
      tgs = [ "Rest" ]
   }

   # The method lines_per_tgReadFromCatalogues is thus now
   # obsolete. It lead to a couple of bugs, because the order of
   # the tags was mixed up by the user.


   # The purpose of gas_abs_tableCalc below is to calculate a lookup
   # table of absorption coefficients for all gas components.

   # The temperature perturbations for which the table should be
   # calculated (in K).
   VectorDefine(delta_t){[-10-5,0,5,10]}

   # The water vapor perturbations for which the table should be
   # calculated (as factors, .9 means 90% of the reference profile
   # value).  
   VectorDefine(delta_h2o){[.01,.1,0,10,100]}

   # Inside the braces for this method you should define a method list
   # that computes gas_abs_per_tg for given temperature and water vapor
   # (and pressure and other concentrations). This is used repeatedly
   # by gas_abs_tableCalc to calculate the table.
   #
   # Variables delta_t and delta_h2o specify the extent of the table
   # in temperature and vater vapor mixing ratio.
   #
   # The comunication variable gas_abs_per_tg is initialized by
   # gas_abs_tableCalc. Don't forget that gas_abs_tableCalc must also
   # set gas_abs_per_tg to zero every time before recalculating! Also,
   # at the begining of each recalculation, the WSV lbl_tgs_todo is
   # re-set to indices of those tags that do not have the "nl"
   # atribute. This is necessary to allow simple computation of all
   # remaining species by "Rest"
   #
   # Absorption method output:
   # gas_abs_per_tg
   #
   # Absorption method input:
   # p_abs (external)
   # lines_per_tg (external)
   # lbl_tgs_todo (for which tags line by line absorption should be calculated)
   # t_abs (manipulated by gas_abs_tableCalc)
   # vmrs (manipulated by gas_abs_tableCalc (first H2O))
    
   gas_abs_tableCalc {

      # Add explicit line spectra (using lines from external catalogues).

      # Set the names of the tgs to calculate. Must correspond
      # to one or more of gas_tgs. As special case, Rest will
      # calculate for all remaining components.
      # This method is the only one that has to use lbl_tgs_todo.
      these_tgsSelect{ ["H2O"] }

      # The next function computes the line spectrum for these_tgs and
      # adds it to gas_abs_per_tg. In the curly braces it wants a list
      # of methods to compute the lineshape. This list must handle
      # everything, including cutoffs and normalization factors. It
      # can also handle mirror lines. I guess that makes
      # lines_per_tgAddMirrorLines and lines_per_tgReduce obsolete.
      #
      # At one point, the method calls the lineshape method list to
      # compute the lineshape.  Communication between the lineshape
      # method list and gas_abs_per_tgAdd is via the WSVs:
      #
      # Output of lineshape method list:
      # ls: The lineshape 
      # 
      # Input to lineshape method list:
      # ls_f0: Line center frequency
      # ls_gamma: The pressure broadening parameter
      # ls_sigma: The Doppler broadening parameter
      # ls_f_mono: Frequency grid

      gas_abs_per_tgAddLines {

	 # Total lineshape methods here.

         # The following method implements the cutoff. The methods inside the
         # curly braces are only executed if they are inside the
         # cutoff for at least part of f_mono. After execution, the
         # value at the cutoff is subtracted from the result.
         #
         # To compute the lineshape value at the cutoff, an apropriate
         # frequency has to be added to the list of frequencies for
         # calculation. So, internally the WSV ls_f_mono_local is used
         # to pass the frequencies for the lineshape function.
         #
	 # After the elementary lineshape function is finished,
         # elements of ls outside the cutoff are set to zero and the
         # value at the cutoff is subtracted.

	 NumericSet(ls_cutoff){750e9}  # Cutoff at 750 GHz
         lsCalculate{
	    # Lineshape method without cutoff here.
            lsVoigtKunz6{}
         }

	 # Add the mirror line:
         NumericScale(ls_f0,ls_f0){-1}
         lsCalculate{
	    # Lineshape method without cutoff here.
            lsVoigtKunz6{}
         }

      }

      # Simpler treatment for the rest of the line by line gases (no
      # cutoffs, no mirror lines)
      these_tgsSelect{ ["Rest"] }
      gas_abs_per_tgAddLines{
         lsVoigtKunz6{}
      }
    
      # Now let's add some continua.  

      # The tg to which to add is selected by this_tg. So we need both
      # these_tgs and this_tg, unfortunately. Both are just
      # ArrayOfIndex, not strings, since they refer to gas_tgs. Ok,
      # maybe one could use these_tgs in both places, but then
      # gas_abs_per_tgAddToThisTg has to check that there really is
      # just one.

      this_tgSelect{"H2O"}

      # The next method just calls the methods given in the argument and
      # ads the result to this_tg. Communication is by:
      #
      # Output of continuum methods:
      # gas_abs (dimension: [f_mono, p_abs]) (Used to be called just abs.)
      #
      # Input to continuum methods:
      # f_mono
      # p_abs
      # t_abs
      # vmrs
      # this_tg: (To find the right one in vmrs)
      #
      # We have to pass all vmrs, since some continua depend not only
      # on the VMR of the target species (example: Rosenkranz O2
      # depends on H2O).

      gas_abs_per_tgAddToThisTg{

         # The continuum method will also require that possible
         # additional parameters have been set This would be a good
         # place to do it.

         # FIXME: Discuss with Thomas how he does the fitting. Could
         # parameters also be keyword arguments to the continuum
         # functions? 

         gas_absH2O-SelfContStandardType{
	    model = "Rosenkranz"
	    strength = 1e-19
	    T_exp = 3.5
         }

	 # Let's take our own values for the foreign continuum:
         gas_absStandard_H2O_foreign_continuum{
	    model = "user"
            userparameters = [ 1.3e-19, 1.5 ]
         }
      }

      # Oxygen continuum:
      this_tgSelect{"O2"}
      gas_abs_per_tgAddToThisTg{
         gas_absO2-SelfContPWR93{
	    model = Rosenkranz
            userparameters = []
         }
      }   

      # Nitrogen continuum:
      this_tgSelect{"N2"}
      gas_abs_per_tgAddToThisTg{
         gas_absN2-SelfContPWR93{
	    model = Rosenkranz
            userparameters = []
         }
      }   
   }

}
