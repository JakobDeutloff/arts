#
# How should the Controlfile of the future look like?
# This is one that computes the gas absorption lookup table
# gas_abs_table. 
#
# Put an agenda into a WSV:
#
# AgendaSet(some_agena){
#    some_method{}
#    some_other_method{}
# }
#
# Execute an agenda directly (Not used very often):
#
# AgendaExecute(some_agenda)
#
# Otherwise, the defined agenda can be used by some method to do some
# specific thing. Convention: Try to define an agenda with AgendaSet,
# just before it is used.

AgendaSet(main_agenda) {

   # Rename tgs to gas_tgs, to make the distinction from
   # particles. Furthermore, we introduce a new tag atribute "-nl", which
   # can be used instead of the istotope and means that no explicit
   # lines (from line catalouges) should be considered for this tag.

   gas_tgsDefine{
      ["H2O","O2","O3-666","O3","N2O","N2-nl"]
   }

   # FIXME: Somehow load the atmosphere and the concentration
   # profiles. Should there be separate loading methods for the
   # different dimensions?

   # Create the frequency grid `f_mono':
   VectorNLinSpace(f_mono){
           start = 50e9
           stop  = 150e9
           n     = 100    
   }

   # The next task is to somehow assign the right spectral lines to
   # those gas_components for which explicit line-by-line calculations
   # should be done. 
	
   # Set all line lists to empty
   lines_per_tgInit{}

   linesReadFromArts {
      filename = "thomas.al"
      fmin     = 1e9
      fmax     = 200e9
   }

   # This will put the matching lines in the apropriate line list.
   lines_per_tgPut{
      tgs = [ "H2O"    ]
   }

   linesReadFromHitran {
      filename = "/pool/lookup2/arts-data/spectroscopy/hitran96/hitran96_lowfreq.par"
      fmin     = 1e9
      fmax     = 200e9
   }

   # This will consider all tgs for which the line list is still empty.
   lines_per_tgPut{
      tgs = [ "Rest" ]
   }

   # The method lines_per_tgReadFromCatalogues is thus now
   # obsolete. It lead to a couple of bugs, because the order of
   # the tags was mixed up by the user.


   # Now we define a method list that computes gas_abs_per_tg for
   # given temperature and water vapor (and pressure and other
   # concentrations). This can for example be used repeatedly by
   # gas_abs_tableCalc to calculate an absorption lookup table.
   #
   # Absorption method output:
   # gas_abs_per_tg
   #
   # Absorption method input:
   # p_abs (external)
   # lines_per_tg (external)
   # lbl_tgs_todo (for which tags line by line absorption should be calculated)
   # t_abs (may be manipulated by gas_abs_tableCalc)
   # vmrs (may be manipulated by gas_abs_tableCalc (first H2O))
    
   AgendaSet(gas_abs_per_tg_agenda) {

      # Add explicit line spectra (using lines from external catalogues).

      # Set the names of the tgs to calculate. Must correspond
      # to one or more of gas_tgs. As special case, Rest will
      # calculate for all remaining components.
      # This method is the only one that has to use lbl_tgs_todo.
      these_tgsSelect{ ["H2O"] }

      # Let's define a list of methods to compute the lineshape. This
      # list must handle everything, including cutoffs and
      # normalization factors. It can also handle mirror lines. I
      # guess that makes lines_per_tgAddMirrorLines and
      # lines_per_tgReduce obsolete.
      #
      # Output of lineshape method list:
      # ls: The lineshape 
      # 
      # Input to lineshape method list:
      # ls: Presumably set to 0 by calling method
      # ls_f0: Line center frequency
      # ls_gamma: The pressure broadening parameter
      # ls_sigma: The Doppler broadening parameter
      # f_mono: Frequency grid

      AgendaSet(total_lineshape_agenda) {

	 # Total lineshape methods here.

	 # First define the elementary lineshape function (simple
         # symetric shape, no scaling factor, no cutoff).
         #
	 # After the elementary lineshape function is finished,
         # elements of ls outside the cutoff are set to zero and the
         # value at the cutoff is subtracted.

      	 # Output of lineshape method list:
      	 # ls: The lineshape 
      	 # 
      	 # Input to lineshape method list:
      	 # ls: The lineshape to add to
      	 # ls_f0: Line center frequency
      	 # ls_gamma: The pressure broadening parameter
      	 # ls_sigma: The Doppler broadening parameter
      	 # ls_f_mono: Frequency grid, local copy of f_mono, see also below

	 AgendaSet(elementary_lineshape_agenda) { lsVoigtKunz6{} }

	 NumericSet(ls_cutoff){750e9}  # Cutoff at 750 GHz

         # The following method implements the cutoff. The methods
         # given by elementary_lineshape_agenda are only executed if
         # they are inside the cutoff for at least part of
         # f_mono. After execution, the value at the cutoff is
         # subtracted from the result.
         #
         # To compute the lineshape value at the cutoff, an apropriate
         # frequency has to be added to the list of frequencies for
         # calculation. So, internally the WSV ls_f_mono is used to
         # pass the frequencies for the lineshape function, rather
         # than the global f_mono.

         lsWithCutoffAdd{} # uses ls_cutoff and elementary_lineshape_agenda

	 # Add the mirror line:
         NumericScale(ls_f0,ls_f0){-1}

         lsWithCutoffAdd{} # also uses ls_cutoff and elementary_lineshape_agenda
	
         # Define the agenda for the lineshape norm.
         #
         # Output:
         # ls_norm
         #
         # Input:
         # f_mono
         # ls_f0
	 AgendaSet(ls_norm_agenda){ ls_normQuadratic{} }

         lsApplyNorm(ls_norm_agenda)
      }

      # The next function computes the line spectrum for these_tgs and
      # adds it to gas_abs_per_tg. It uses the total_lineshape_agenda
      # that we have defined above.

      gas_abs_per_tgAddLines {} # uses these_tgs and total_lineshape_agenda


      # Simpler treatment for the rest of the line by line gases (no
      # cutoffs, no mirror lines)
      these_tgsSelect{ ["Rest"] }
      AgendaSet(total_lineshape_agenda) { 
         lsVoigtKunz6{} 
         lsApplyNorm(ls_norm_agenda) # we can re-use the ls-norm agenda defined above
      }
      gas_abs_per_tgAddLines{} # uses the new these_tgs and total_lineshape_agenda
    
      # Now let's add some continua.  

      # The tg to which to add is selected by this_tg. So we need both
      # these_tgs and this_tg, unfortunately. Both are just
      # ArrayOfIndex, not strings, since they refer to gas_tgs. Ok,
      # maybe one could use these_tgs in both places, but then
      # gas_abs_per_tgAddToThisTg has to check that there really is
      # just one.

      this_tgSelect{"H2O"}

      # Output of continuum methods:
      # gas_abs (dimension: [f_mono, p_abs]) (Used to be called just abs.)
      #
      # Input to continuum methods:
      # f_mono
      # p_abs
      # t_abs
      # vmrs
      # this_tg: (To find the right one in vmrs)
      #
      # We have to pass all vmrs, since some continua depend not only
      # on the VMR of the target species (example: Rosenkranz O2
      # depends on H2O).

      AgendaSet(gas_abs_agenda) {

         # The continuum method will also require that possible
         # additional parameters have been set This would be a good
         # place to do it.

         gas_absH2O-Cont-ARTS02_tks{}

      }

      # The next method just calls gas_abs_agenda for this_tg, takes
      # the result from gas_abs, and adds it to the right element of
      # gas_abs_per_tg.

      gas_abs_per_tgAddToThisTg{} # compute gas_abs with gas_abs_agenda, 
                                  # and add to the right part of gas_abs_per_tg
      

      # Oxygen continuum:
      this_tgSelect{"O2"}
      AgendaSet(gas_abs_agenda) { gas_absO2-Cont-ARTS02_tks {} }          
      gas_abs_per_tgAddToThisTg{} # again use this_tg and gas_abs_agenda

      # Nitrogen continuum:
      this_tgSelect{"N2"}
      AgendaSet(gas_abs_agenda) { gas_absN2-Cont-ARTS02_tks {} }
      gas_abs_per_tgAddToThisTg{}
        
   }


   # The temperature perturbations for which the table should be
   # calculated (in K).
   VectorDefine(delta_t){[-10-5,0,5,10]}

   # The water vapor perturbations for which the table should be
   # calculated (as factors, .9 means 90% of the reference profile
   # value).  
   VectorDefine(delta_h2o){[.01,.1,0,10,100]}

   # The purpose of gas_abs_tableCalc below is to calculate a lookup
   # table of absorption coefficients for all gas components.
   # Variables delta_t and delta_h2o specify the extent of the table
   # in temperature and vater vapor mixing ratio.
   #
   # The comunication variable gas_abs_per_tg is initialized by
   # gas_abs_tableCalc. Don't forget that gas_abs_tableCalc must also
   # set gas_abs_per_tg to zero every time before recalculating! Also,
   # at the begining of each recalculation, the WSV lbl_tgs_todo is
   # re-set to indices of those tags that do not have the "nl"
   # atribute. This is necessary to allow simple computation of all
   # remaining species by "Rest"

   gas_abs_tableCalc {} # uses gas_abs_per_tg_agenda

}
