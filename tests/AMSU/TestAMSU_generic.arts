#DEFINITIONS:  -*-sh-*-

# --------------------------------------------------------------------
# This is the part of the TestAMSU control files that is the same for
# AMSU-A and AMSU-B.
# 
# DO NOT RUN THIS FILE DIRECTLY, RUN TestAMSUA.arts or TestAMSUB.arts!
# --------------------------------------------------------------------

Arts {

# Set up absorption
# =================

# Atmospheric profiles
# ---
# Atmospheric profiles are stored in an ArrayOfMatrix.
# It contains one matrix for each atmospheric state.
# Each matrix row corresponds to one pressure level. The
# meaning of the columns is:
# p[Pa]        T[K]         z[m]         H2O[VMR]	O3[VMR]
#
#ReadXML(arrayofmatrix_1){"/storage2/home/sbuehler/checkouts/arts-xml-data/atmosphere/chevallier_91L/chevallierl91_clear_q.xml"}
ArrayOfMatrixCreate(arrayofmatrix_1)
ReadXML(arrayofmatrix_1){"chevallierl91_clear_q_extract.xml"}

# Storage in an array of matrix is handy for Chevallier data, because
# it is very compact. However, the more general internal
# representation of the data is in batch_atm_fields_compact.

# Convert to batch_atm_fields_compact
# ---
# The values taken for O2 and N2 are from Wallace&Hobbs, 2nd edition.
batch_atm_fields_compactFromArrayOfMatrix(arrayofmatrix_1){
   field_names        = ["T", "z", "H2O", "O3"]
   extra_field_names  = ["O2", "N2"]
   extra_field_values = [0.2095, 0.7808]
}

# Delete original data array to conserve memory:
# ---
Delete(arrayofmatrix_1)

# Set parameters for lookup table
# ---
abs_lookupSetupBatch


# Optional manual override of T and VMR perturbations
# ---
# If your input data contains extreme outliers, the lookup table will
# get unreasonably large. It is suggested that you instead set them
# manually here. The Chevallier 91L data (humidity set) contains
# temperature variations from -70 to +55 (K) and humidity variations from
# 0 to 6 (fractional units). This should be the reasonable range of
# atmospheric variability. You will get failures from individual jobs in
# the batch, that are outside this range.
#VectorLinSpace(abs_t_pert){start = -70
#                           stop  = 55
#                           step  = 5 }
#VectorLinSpace(abs_nls_pert){start = 0
#                             stop  = 6
#                             step  = 0.5}


# Create the lookup table
# ---
abs_lookupCreate

# Set abs_scalar_gas_agenda to use lookup table
# ---
AgendaSet(abs_scalar_gas_agenda){
  abs_scalar_gasExtractFromLookup
}

# Set up RT calculation
# =====================

# Set surface emissivity
# ---
# Here we take a value representative for the sea surface.
NumericSet(surface_emissivity){0.6}


# Definition of sensor position and LOS
# ---

# Optionally set sensor_pos
# ---
# The sensor altitude is predefined in amsu.arts to 850 km above the geoid. 
# Comment out the next four lines if you want to set it to something else.
IndexSet(nrows){ 1 }
IndexSet(ncols){ 1 }
MatrixSet(sensor_pos){850e3}
sensor_posAddRgeoid


# Optionally set sensor_los
# ---
# The sensor viewing directions for AMSU-B are predefined in amsu.arts. 
# There are 45 different angles, corresponding to one side of the AMSU-B
# Scan. You can instead set it here to a single value if you want to 
# calculate only for one viewing angle.
IndexSet(nrows){ 1 }
IndexSet(ncols){ 1 }
MatrixSet(sensor_los){180}

# Set the agenda for batch calculations:
# ---
#
AgendaSet(ybatch_calc_agenda){
  
  # Extract the atmospheric profiles for this case:
  GriddedField4ExtractFromArrayOfGriddedField4(
    atm_fields_compact, 
    batch_atm_fields_compact, 
    ybatch_index
  )

  # Split up *atm_fields_compact* to
  # generate p_grid, t_field, z_field, vmr_field:
  AtmFieldsFromCompact

  # Optionally set jacobian parameters:
#   jacobianInit
#   jacobianAddAbsSpecies(p_grid, lat_grid, lon_grid){
#        species = "H2O-PWR98"
#        method = "analytical"
#        unit   = "rel"
#        dx     = 0.01 
#   }
#   jacobianClose

  # get z_surface from z_field
  IndexSet(index_1){0}
  MatrixExtractFromTensor3(z_surface,z_field,index_1)
  #  Print(z_surface){1}

  # Perform RT calculations
  # ---
  RteCalc

  Copy(file_index, ybatch_index)
  # Optionally write out jacobian:
#  WriteXMLIndexed(jacobian){""}

}


# Set number of batch cases:
nelemGet(batch_atm_fields_compact)
Copy(ybatch_n, nelem)
#IndexSet(ybatch_n){10}

# Execute the batch calculations:
# ---
ybatchCalc

}
